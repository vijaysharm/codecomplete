{
  "Summary": {
    "Name": "Pattern Matcher",
    "Category": "Strings",
    "Difficulty": 3,
    "Available": true,
    "Metadata": {
      "number": 6,
      "timeOne": 0,
      "timeTwo": 1633,
      "url": "https://player.vimeo.com/video/226841210"
    }
  },
  "Prompt": "",
  "Hints": "Start by checking if the pattern starts with an \"x\". If it doesn't, consider generating a new pattern that swaps all \"x\"s for \"y\"s and vice-versa; this might greatly simplify the rest of your algorithm. Make sure to keep track of whether or not you do this swap, as your final answer will be affected by it.\nUse a hash table to store the number of \"x\"s and \"y\"s that appear in the pattern, and keep track of the position of the first \"y\". Knowing how many \"x\"s and \"y\"s appear in the pattern, paired with the length of the main string which you have access to, will allow you to quickly test out various possible lengths for \"x\" and \"y\". Knowing where the first \"y\" appears in the pattern will allow you to actually generate potential substrings.\nTraverse the main string and try different combinations of substrings that could represent \"x\" and \"y\". For each potential combination, map the new pattern mentioned in Hint #1 and see if it matches the main string.\n",
  "SpaceTime": "O(n^2 + m) time | O(n + m) space - where n is the length of the main string and m is the length of the pattern\n",
  "PromptHTML": "<p>\n  You're given two non-empty strings. The first one is a pattern consisting of\n  only <span>\"x\"</span>s and / or <span>\"y\"</span>s; the other one is a normal\n  string of alphanumeric characters. Write a function that checks whether the\n  normal string matches the pattern.\n</p>\n<p>\n  A string <span>S0</span> is said to match a pattern if replacing all\n  <span>\"x\"</span>s in the pattern with some substring <span>S1</span> of\n  <span>S0</span> and replacing all <span>\"y\"</span>s in the pattern with some\n  substring <span>S2</span> of <span>S0</span> yields the same string\n  <span>S0</span>.\n</p>\n<p>\n  If the input string doesn't match the input pattern, the function should\n  return an empty array; otherwise, it should return an array holding the\n  strings <span>S0</span> and <span>S1</span> that represent\n  <span>\"x\"</span> and <span>\"y\"</span> in the normal string, in that order. If\n  the pattern doesn't contain any <span>\"x\"</span>s or <span>\"y\"</span>s, the\n  respective letter should be represented by an empty string in the final array\n  that you return.\n</p>\n<p>\n  You can assume that there will never be more than one pair of strings\n  <span>S1</span> and <span>S2</span> that appropriately represent\n  <span>\"x\"</span> and <span>\"y\"</span> in the normal string.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">pattern</span> = \"xxyxxy\"\n<span class=\"CodeEditor-promptParameter\">string</span> = \"gogopowerrangergogopowerranger\"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[\"go\", \"powerranger\"]\n</pre>\n",
  "Notes": "",
  "IsLongOutput": false,
  "Visualization": {
    "inputType": null,
    "outputType": null
  },
  "CustomInputLanguages": [
    "javascript",
    "cpp",
    "python",
    "java",
    "csharp",
    "go",
    "swift",
    "typescript"
  ],
  "CustomInputVars": [
    {
      "Name": "pattern",
      "Example": "xxyxxy",
      "Schema": {
        "minLength": 1,
        "type": "string"
      }
    },
    {
      "Name": "string",
      "Example": "gogopowerrangergogopowerranger",
      "Schema": {
        "minLength": 1,
        "type": "string"
      }
    }
  ],
  "Resources": {
    "cpp": {
      "Language": "cpp",
      "StartingCode": "#include <vector>\nusing namespace std;\n\nvector<string> patternMatcher(string pattern, string str) {\n  // Write your code here.\n  return {};\n}\n",
      "StartingTest": "class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n\n    RunTest(\"Test Case 1\", []() {\n      vector<string> expected{\"a\", \"b\"};\n      assert(patternMatcher(\"xyxy\", \"abab\") == expected);\n    });\n\n    RunTest(\"Test Case 2\", []() {\n      vector<string> expected{\"b\", \"a\"};\n      assert(patternMatcher(\"yxyx\", \"abab\") == expected);\n    });\n\n    RunTest(\"Test Case 3\", []() {\n      vector<string> expected{\"ma\", \"yo\"};\n      assert(patternMatcher(\"yxx\", \"yomama\") == expected);\n    });\n\n    RunTest(\"Test Case 4\", []() {\n      vector<string> expected{\"go\", \"powerranger\"};\n      assert(patternMatcher(\"xxyxxy\", \"gogopowerrangergogopowerranger\") ==\n             expected);\n    });\n\n    RunTest(\"Test Case 5\", []() {\n      vector<string> expected{\"powerranger\", \"go\"};\n      assert(patternMatcher(\"yyxyyx\", \"gogopowerrangergogopowerranger\") ==\n             expected);\n    });\n\n    RunTest(\"Test Case 6\", []() {\n      vector<string> expected{\"baddaddoom\", \"baddaddoomi\"};\n      assert(\n          patternMatcher(\"xyxxxyyx\",\n                         \"baddaddoombaddaddoomibaddaddoombaddaddoombaddaddoom\"\n                         \"baddaddoomibaddaddoomibaddaddoom\") == expected);\n    });\n\n    RunTest(\"Test Case 7\", []() {\n      vector<string> expected{\"baddaddoomi\", \"baddaddoom\"};\n      assert(\n          patternMatcher(\"yxyyyxxy\",\n                         \"baddaddoombaddaddoomibaddaddoombaddaddoombaddaddoom\"\n                         \"baddaddoomibaddaddoomibaddaddoom\") == expected);\n    });\n\n    RunTest(\"Test Case 8\", []() {\n      vector<string> expected{};\n      assert(patternMatcher(\"xxyxyy\", \"testtestwrongtestwrongtest\") ==\n             expected);\n    });\n\n    RunTest(\"Test Case 9\", []() {\n      vector<string> expected{};\n      assert(\n          patternMatcher(\"xyxxxyyx\",\n                         \"baddaddoombaddadoomibaddaddoombaddaddoombaddaddoomb\"\n                         \"addaddoomibaddaddoomibaddaddoom\") == expected);\n    });\n\n    RunTest(\"Test Case 10\", []() {\n      vector<string> expected{};\n      assert(patternMatcher(\"xyx\", \"thisshouldobviouslybewrong\") == expected);\n    });\n\n    RunTest(\"Test Case 11\", []() {\n      vector<string> expected{\"test\", \"\"};\n      assert(patternMatcher(\"xxxx\", \"testtesttesttest\") == expected);\n    });\n\n    RunTest(\"Test Case 12\", []() {\n      vector<string> expected{\"\", \"test\"};\n      assert(patternMatcher(\"yyyy\", \"testtesttesttest\") == expected);\n    });\n  }\n};\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<string> expected{\"go\", \"powerranger\"};\n      assert(patternMatcher(\"xxyxxy\", \"gogopowerrangergogopowerranger\") ==\n             expected);\n    });\n  }\n};\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <unordered_map>\n#include <math.h>\nusing namespace std;\n\nvector<char> getNewPattern(string pattern);\nint getCountsAndFirstYPos(vector<char> pattern,\n                          unordered_map<char, int> *counts);\n\n// O(n^2 + m) time | O(n + m) space\nvector<string> patternMatcher(string pattern, string str) {\n  if (pattern.length() > str.length()) {\n    return vector<string>{};\n  }\n  vector<char> newPattern = getNewPattern(pattern);\n  bool didSwitch = newPattern[0] != pattern[0];\n  unordered_map<char, int> counts({{'x', 0}, {'y', 0}});\n  int firstYPos = getCountsAndFirstYPos(newPattern, &counts);\n  if (counts['y'] != 0) {\n    for (int lenOfX = 1; lenOfX < str.length(); lenOfX++) {\n      double lenOfY =\n          ((double)str.length() - (double)lenOfX * (double)counts['x']) /\n          (double)counts['y'];\n      if (lenOfY <= 0 || fmod(lenOfY, 1) != 0) {\n        continue;\n      }\n      int yIdx = firstYPos * lenOfX;\n      string x = str.substr(0, lenOfX);\n      string y = str.substr(yIdx, lenOfY);\n      vector<string> potentialMatch(newPattern.size(), \"\");\n      transform(newPattern.begin(), newPattern.end(), potentialMatch.begin(),\n                [x, y](char c) -> string { return c == 'x' ? x : y; });\n      if (str == accumulate(potentialMatch.begin(), potentialMatch.end(),\n                            string(\"\"))) {\n        return !didSwitch ? vector<string>{x, y} : vector<string>{y, x};\n      }\n    }\n  } else {\n    double lenOfX = str.length() / counts['x'];\n    if (fmod(lenOfX, 1) == 0) {\n      string x = str.substr(0, lenOfX);\n      vector<string> potentialMatch(newPattern.size(), \"\");\n      transform(newPattern.begin(), newPattern.end(), potentialMatch.begin(),\n                [x](char c) -> string { return x; });\n      if (str == accumulate(potentialMatch.begin(), potentialMatch.end(),\n                            string(\"\"))) {\n        return !didSwitch ? vector<string>{x, \"\"} : vector<string>{\"\", x};\n      }\n    }\n  }\n  return vector<string>{};\n}\n\nvector<char> getNewPattern(string pattern) {\n  vector<char> patternLetters(pattern.begin(), pattern.end());\n  if (pattern[0] == 'x') {\n    return patternLetters;\n  } else {\n    transform(patternLetters.begin(), patternLetters.end(),\n              patternLetters.begin(),\n              [](char c) -> char { return c == 'y' ? 'x' : 'y'; });\n    return patternLetters;\n  }\n}\n\nint getCountsAndFirstYPos(vector<char> pattern,\n                          unordered_map<char, int> *counts) {\n  int firstYPos = -1;\n  for (int i = 0; i < pattern.size(); i++) {\n    char c = pattern[i];\n    counts->at(c)++;\n    if (c == 'y' && firstYPos == -1) {\n      firstYPos = i;\n    }\n  }\n  return firstYPos;\n}\n"
      ]
    },
    "csharp": {
      "Language": "csharp",
      "StartingCode": "public class Program {\n\tpublic static string[] PatternMatcher(string pattern, string str) {\n\t\t// Write your code here.\n\t\treturn null;\n\t}\n}\n",
      "StartingTest": "public class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tstring[] expected = {\"a\", \"b\"};\n\t\tstring inputPattern = \"xyxy\";\n\t\tstring inputstring = \"abab\";\n\t\tUtils.AssertTrue(compare(Program.PatternMatcher(inputPattern,\n\t\t  inputstring), expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase2() {\n\t\tstring[] expected = {\"b\", \"a\"};\n\t\tstring inputPattern = \"yxyx\";\n\t\tstring inputstring = \"abab\";\n\t\tUtils.AssertTrue(compare(Program.PatternMatcher(inputPattern,\n\t\t  inputstring), expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase3() {\n\t\tstring[] expected = {\"ma\", \"yo\"};\n\t\tstring inputPattern = \"yxx\";\n\t\tstring inputstring = \"yomama\";\n\t\tUtils.AssertTrue(compare(Program.PatternMatcher(inputPattern,\n\t\t  inputstring), expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase4() {\n\t\tstring[] expected = {\"go\", \"powerranger\"};\n\t\tstring inputPattern = \"xxyxxy\";\n\t\tstring inputstring = \"gogopowerrangergogopowerranger\";\n\t\tUtils.AssertTrue(compare(Program.PatternMatcher(inputPattern,\n\t\t  inputstring), expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase5() {\n\t\tstring[] expected = {\"powerranger\", \"go\"};\n\t\tstring inputPattern = \"yyxyyx\";\n\t\tstring inputstring = \"gogopowerrangergogopowerranger\";\n\t\tUtils.AssertTrue(compare(Program.PatternMatcher(inputPattern,\n\t\t  inputstring), expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase6() {\n\t\tstring[] expected = {\"baddaddoom\", \"baddaddoomi\"};\n\t\tstring inputPattern = \"xyxxxyyx\";\n\t\tstring inputstring =\n\t\t  \"baddaddoombaddaddoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom\";\n\t\tUtils.AssertTrue(compare(Program.PatternMatcher(inputPattern,\n\t\t  inputstring), expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase7() {\n\t\tstring[] expected = {\"baddaddoomi\", \"baddaddoom\"};\n\t\tstring inputPattern = \"yxyyyxxy\";\n\t\tstring inputstring =\n\t\t  \"baddaddoombaddaddoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom\";\n\t\tUtils.AssertTrue(compare(Program.PatternMatcher(inputPattern,\n\t\t  inputstring), expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase8() {\n\t\tstring[] expected = {};\n\t\tstring inputPattern = \"xxyxyy\";\n\t\tstring inputstring = \"testtestwrongtestwrongtest\";\n\t\tUtils.AssertTrue(compare(Program.PatternMatcher(inputPattern,\n\t\t  inputstring), expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase9() {\n\t\tstring[] expected = {};\n\t\tstring inputPattern = \"xyxxxyyx\";\n\t\tstring inputstring =\n\t\t  \"baddaddoombaddadoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom\";\n\t\tUtils.AssertTrue(compare(Program.PatternMatcher(inputPattern,\n\t\t  inputstring), expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase10() {\n\t\tstring[] expected = {};\n\t\tstring inputPattern = \"xyx\";\n\t\tstring inputstring = \"thisshouldobviouslybewrong\";\n\t\tUtils.AssertTrue(compare(Program.PatternMatcher(inputPattern,\n\t\t  inputstring), expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase11() {\n\t\tstring[] expected = {\"test\", \"\"};\n\t\tstring inputPattern = \"xxxx\";\n\t\tstring inputstring = \"testtesttesttest\";\n\t\tUtils.AssertTrue(compare(Program.PatternMatcher(inputPattern,\n\t\t  inputstring), expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase12() {\n\t\tstring[] expected = {\"\", \"test\"};\n\t\tstring inputPattern = \"yyyy\";\n\t\tstring inputstring = \"testtesttesttest\";\n\t\tUtils.AssertTrue(compare(Program.PatternMatcher(inputPattern,\n\t\t  inputstring), expected));\n\t}\n\n\tpublic bool compare(string[] arr1, string[] arr2) {\n\t\tif (arr1.Length != arr2.Length) {\n\t\t\treturn false;\n\t\t}\n\t\tif (arr1.Length == 0 && arr2.Length == 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn arr1[0].Equals(arr2[0]) && arr1[1].Equals(arr2[1]);\n\t}\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tstring[] expected = {\"go\", \"powerranger\"};\n\t\tstring inputPattern = \"xxyxxy\";\n\t\tstring inputstring = \"gogopowerrangergogopowerranger\";\n\t\tUtils.AssertTrue(compare(Program.PatternMatcher(inputPattern,\n\t\t  inputstring), expected));\n\t}\n\n\tpublic bool compare(string[] arr1, string[] arr2) {\n\t\tif (arr1.Length != arr2.Length) {\n\t\t\treturn false;\n\t\t}\n\t\tif (arr1.Length == 0 && arr2.Length == 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn arr1[0].Equals(arr2[0]) && arr1[1].Equals(arr2[1]);\n\t}\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nusing System.Text;\nusing System.Collections.Generic;\n\npublic class Program {\n\t// O(n^2 + m) time | O(n + m) space\n\tpublic static string[] PatternMatcher(string pattern, string str) {\n\t\tif (pattern.Length > str.Length) {\n\t\t\treturn new string[] {};\n\t\t}\n\t\tchar[] newPattern = getNewPattern(pattern);\n\t\tbool didSwitch = newPattern[0] != pattern[0];\n\t\tDictionary<char, int> counts = new Dictionary<char, int>();\n\t\tcounts['x'] = 0;\n\t\tcounts['y'] = 0;\n\t\tint firstYPos = getCountsAndFirstYPos(newPattern, counts);\n\t\tif (counts['y'] != 0) {\n\t\t\tfor (int lenOfX = 1; lenOfX < str.Length; lenOfX++) {\n\t\t\t\tdouble lenOfY =\n\t\t\t\t  ((double)str.Length - (double)lenOfX *\n\t\t\t\t  (double)counts['x']) /\n\t\t\t\t  (double)counts['y'];\n\t\t\t\tif (lenOfY <= 0 || lenOfY % 1 != 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint yIdx = firstYPos * lenOfX;\n\t\t\t\tstring x = str.Substring(0, lenOfX);\n\t\t\t\tstring y = str.Substring(yIdx, (int)lenOfY);\n\t\t\t\tstring potentialMatch = buildPotentialMatch(newPattern, x, y);\n\t\t\t\tif (str.Equals(potentialMatch)) {\n\t\t\t\t\treturn didSwitch ? new string[] {y, x} : new string[] {x,\n\t\t\t\t\t\t                                               y};\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdouble lenOfX = str.Length / counts['x'];\n\t\t\tif (lenOfX % 1 == 0) {\n\t\t\t\tstring x = str.Substring(0, (int)lenOfX);\n\t\t\t\tstring potentialMatch = buildPotentialMatch(newPattern, x, \"\");\n\t\t\t\tif (str.Equals(potentialMatch)) {\n\t\t\t\t\treturn didSwitch ? new string[] {\"\", x} : new string[] {x,\n\t\t\t\t\t\t                                                \"\"};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new string[] {};\n\t}\n\n\tpublic static char[] getNewPattern(string pattern) {\n\t\tchar[] patternLetters = pattern.ToCharArray();\n\t\tif (pattern[0] == 'x') {\n\t\t\treturn patternLetters;\n\t\t}\n\t\tfor (int i = 0; i < patternLetters.Length; i++) {\n\t\t\tif (patternLetters[i] == 'x') {\n\t\t\t\tpatternLetters[i] = 'y';\n\t\t\t} else {\n\t\t\t\tpatternLetters[i] = 'x';\n\t\t\t}\n\t\t}\n\t\treturn patternLetters;\n\t}\n\n\tpublic static int getCountsAndFirstYPos(char[] pattern, Dictionary<char, int> counts) {\n\t\tint firstYPos = -1;\n\t\tfor (int i = 0; i < pattern.Length; i++) {\n\t\t\tchar c = pattern[i];\n\t\t\tcounts[c] = counts[c] + 1;\n\t\t\tif (c == 'y' && firstYPos == -1) {\n\t\t\t\tfirstYPos = i;\n\t\t\t}\n\t\t}\n\t\treturn firstYPos;\n\t}\n\n\tpublic static string buildPotentialMatch(char[] pattern, string x, string y) {\n\t\tStringBuilder potentialMatch = new StringBuilder();\n\t\tforeach (char c in pattern) {\n\t\t\tif (c == 'x') {\n\t\t\t\tpotentialMatch.Append(x);\n\t\t\t} else {\n\t\t\t\tpotentialMatch.Append(y);\n\t\t\t}\n\t\t}\n\t\treturn potentialMatch.ToString();\n\t}\n}\n"
      ]
    },
    "go": {
      "Language": "go",
      "StartingCode": "package main\n\nfunc PatternMatcher(pattern, str string) []string {\n\t// Write your code here.\n\treturn nil\n}\n",
      "StartingTest": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []string{\"a\", \"b\"}\n\toutput := PatternMatcher(\"xyxy\", \"abab\")\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase2(t *TestCase) {\n\texpected := []string{\"b\", \"a\"}\n\toutput := PatternMatcher(\"yxyx\", \"abab\")\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase3(t *TestCase) {\n\texpected := []string{\"ma\", \"yo\"}\n\toutput := PatternMatcher(\"yxx\", \"yomama\")\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase4(t *TestCase) {\n\texpected := []string{\"go\", \"powerranger\"}\n\toutput := PatternMatcher(\"xxyxxy\", \"gogopowerrangergogopowerranger\")\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase5(t *TestCase) {\n\texpected := []string{\"powerranger\", \"go\"}\n\toutput := PatternMatcher(\"yyxyyx\", \"gogopowerrangergogopowerranger\")\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase6(t *TestCase) {\n\texpected := []string{\"baddaddoom\", \"baddaddoomi\"}\n\toutput := PatternMatcher(\"xyxxxyyx\", \"baddaddoombaddaddoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom\")\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase7(t *TestCase) {\n\texpected := []string{\"baddaddoomi\", \"baddaddoom\"}\n\toutput := PatternMatcher(\"yxyyyxxy\", \"baddaddoombaddaddoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom\")\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase8(t *TestCase) {\n\texpected := []string{}\n\toutput := PatternMatcher(\"xxyxyy\", \"testtestwrongtestwrongtest\")\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase9(t *TestCase) {\n\texpected := []string{}\n\toutput := PatternMatcher(\"xyxxxyyx\", \"baddaddoombaddadoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom\")\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase10(t *TestCase) {\n\texpected := []string{}\n\toutput := PatternMatcher(\"xyx\", \"thisshouldobviouslybewrong\")\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase11(t *TestCase) {\n\texpected := []string{\"test\", \"\"}\n\toutput := PatternMatcher(\"xxxx\", \"testtesttesttest\")\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase12(t *TestCase) {\n\texpected := []string{\"\", \"test\"}\n\toutput := PatternMatcher(\"yyyy\", \"testtesttesttest\")\n\trequire.Equal(t, expected, output)\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []string{\"go\", \"powerranger\"}\n\toutput := PatternMatcher(\"xxyxxy\", \"gogopowerrangergogopowerranger\")\n\trequire.Equal(t, expected, output)\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\npackage main\n\nimport \"strings\"\n\ntype counts struct {\n\tx int\n\ty int\n}\n\n// O(n^2 + m) time | O(n + m) space\nfunc PatternMatcher(pattern string, str string) []string {\n\tif len(pattern) > len(str) {\n\t\treturn []string{}\n\t}\n\tpattern, switched := getNewPattern(pattern)\n\tcount, firstY := getCountsAndFirstYPos(pattern)\n\tif count.y != 0 {\n\t\tfor lenx := 1; lenx < len(str); lenx++ {\n\t\t\ttotalLeny := len(str) - lenx*count.x\n\t\t\tif len(str) <= lenx*count.x || totalLeny%count.y != 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tleny := totalLeny / count.y\n\t\t\tyindex := firstY * lenx\n\t\t\tx, y := str[:lenx], str[yindex:yindex+leny]\n\t\t\tpotentialMatch := doReplace(pattern, x, y, count)\n\t\t\tif str == potentialMatch {\n\t\t\t\tif !switched {\n\t\t\t\t\treturn []string{x, y}\n\t\t\t\t}\n\t\t\t\treturn []string{y, x}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif len(str)%count.x == 0 {\n\t\t\tlenx := len(str) / count.x\n\t\t\tx := str[:lenx]\n\t\t\tpotentialMatch := strings.Repeat(x, len(pattern))\n\t\t\tif str == potentialMatch {\n\t\t\t\tif !switched {\n\t\t\t\t\treturn []string{x, \"\"}\n\t\t\t\t}\n\t\t\t\treturn []string{\"\", x}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn []string{}\n}\n\nfunc doReplace(pattern, x, y string, count counts) string {\n\tresult := make([]byte, 0)\n\tfor _, r := range pattern {\n\t\tif r == 'x' {\n\t\t\tresult = append(result, []byte(x)...)\n\t\t} else {\n\t\t\tresult = append(result, []byte(y)...)\n\t\t}\n\t}\n\treturn string(result)\n}\n\nfunc getNewPattern(pattern string) (string, bool) {\n\tif pattern[0] == 'x' {\n\t\treturn pattern, false\n\t}\n\trunes := make([]rune, len(pattern))\n\tfor i := range pattern {\n\t\tif pattern[i] == 'x' {\n\t\t\trunes[i] = 'y'\n\t\t} else {\n\t\t\trunes[i] = 'x'\n\t\t}\n\t}\n\treturn string(runes), true\n}\n\nfunc getCountsAndFirstYPos(pattern string) (counts, int) {\n\tfirstY := strings.Index(pattern, \"y\")\n\tcount := counts{}\n\tfor _, r := range pattern {\n\t\tif r == 'x' {\n\t\t\tcount.x += 1\n\t\t} else {\n\t\t\tcount.y += 1\n\t\t}\n\t}\n\treturn count, firstY\n}\n"
      ]
    },
    "java": {
      "Language": "java",
      "StartingCode": "import java.util.*;\n\nclass Program {\n  public static String[] patternMatcher(String pattern, String str) {\n    // Write your code here.\n    return null;\n  }\n}\n",
      "StartingTest": "class ProgramTest {\n  @Test\n  public void TestCase1() {\n    String[] expected = {\"a\", \"b\"};\n    String inputPattern = \"xyxy\";\n    String inputString = \"abab\";\n    Utils.assertTrue(compare(Program.patternMatcher(inputPattern, inputString), expected));\n  }\n\n  @Test\n  public void TestCase2() {\n    String[] expected = {\"b\", \"a\"};\n    String inputPattern = \"yxyx\";\n    String inputString = \"abab\";\n    Utils.assertTrue(compare(Program.patternMatcher(inputPattern, inputString), expected));\n  }\n\n  @Test\n  public void TestCase3() {\n    String[] expected = {\"ma\", \"yo\"};\n    String inputPattern = \"yxx\";\n    String inputString = \"yomama\";\n    Utils.assertTrue(compare(Program.patternMatcher(inputPattern, inputString), expected));\n  }\n\n  @Test\n  public void TestCase4() {\n    String[] expected = {\"go\", \"powerranger\"};\n    String inputPattern = \"xxyxxy\";\n    String inputString = \"gogopowerrangergogopowerranger\";\n    Utils.assertTrue(compare(Program.patternMatcher(inputPattern, inputString), expected));\n  }\n\n  @Test\n  public void TestCase5() {\n    String[] expected = {\"powerranger\", \"go\"};\n    String inputPattern = \"yyxyyx\";\n    String inputString = \"gogopowerrangergogopowerranger\";\n    Utils.assertTrue(compare(Program.patternMatcher(inputPattern, inputString), expected));\n  }\n\n  @Test\n  public void TestCase6() {\n    String[] expected = {\"baddaddoom\", \"baddaddoomi\"};\n    String inputPattern = \"xyxxxyyx\";\n    String inputString =\n        \"baddaddoombaddaddoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom\";\n    Utils.assertTrue(compare(Program.patternMatcher(inputPattern, inputString), expected));\n  }\n\n  @Test\n  public void TestCase7() {\n    String[] expected = {\"baddaddoomi\", \"baddaddoom\"};\n    String inputPattern = \"yxyyyxxy\";\n    String inputString =\n        \"baddaddoombaddaddoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom\";\n    Utils.assertTrue(compare(Program.patternMatcher(inputPattern, inputString), expected));\n  }\n\n  @Test\n  public void TestCase8() {\n    String[] expected = {};\n    String inputPattern = \"xxyxyy\";\n    String inputString = \"testtestwrongtestwrongtest\";\n    Utils.assertTrue(compare(Program.patternMatcher(inputPattern, inputString), expected));\n  }\n\n  @Test\n  public void TestCase9() {\n    String[] expected = {};\n    String inputPattern = \"xyxxxyyx\";\n    String inputString =\n        \"baddaddoombaddadoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom\";\n    Utils.assertTrue(compare(Program.patternMatcher(inputPattern, inputString), expected));\n  }\n\n  @Test\n  public void TestCase10() {\n    String[] expected = {};\n    String inputPattern = \"xyx\";\n    String inputString = \"thisshouldobviouslybewrong\";\n    Utils.assertTrue(compare(Program.patternMatcher(inputPattern, inputString), expected));\n  }\n\n  @Test\n  public void TestCase11() {\n    String[] expected = {\"test\", \"\"};\n    String inputPattern = \"xxxx\";\n    String inputString = \"testtesttesttest\";\n    Utils.assertTrue(compare(Program.patternMatcher(inputPattern, inputString), expected));\n  }\n\n  @Test\n  public void TestCase12() {\n    String[] expected = {\"\", \"test\"};\n    String inputPattern = \"yyyy\";\n    String inputString = \"testtesttesttest\";\n    Utils.assertTrue(compare(Program.patternMatcher(inputPattern, inputString), expected));\n  }\n\n  public boolean compare(String[] arr1, String[] arr2) {\n    if (arr1.length != arr2.length) {\n      return false;\n    }\n    if (arr1.length == 0 && arr2.length == 0) {\n      return true;\n    }\n    return arr1[0].equals(arr2[0]) && arr1[1].equals(arr2[1]);\n  }\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    String[] expected = {\"go\", \"powerranger\"};\n    String inputPattern = \"xxyxxy\";\n    String inputString = \"gogopowerrangergogopowerranger\";\n    Utils.assertTrue(compare(Program.patternMatcher(inputPattern, inputString), expected));\n  }\n\n  public boolean compare(String[] arr1, String[] arr2) {\n    if (arr1.length != arr2.length) {\n      return false;\n    }\n    if (arr1.length == 0 && arr2.length == 0) {\n      return true;\n    }\n    return arr1[0].equals(arr2[0]) && arr1[1].equals(arr2[1]);\n  }\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n^2 + m) time | O(n + m) space\n  public static String[] patternMatcher(String pattern, String str) {\n    if (pattern.length() > str.length()) {\n      return new String[] {};\n    }\n    char[] newPattern = getNewPattern(pattern);\n    boolean didSwitch = newPattern[0] != pattern.charAt(0);\n    Map<Character, Integer> counts = new HashMap<Character, Integer>();\n    counts.put('x', 0);\n    counts.put('y', 0);\n    int firstYPos = getCountsAndFirstYPos(newPattern, counts);\n    if (counts.get('y') != 0) {\n      for (int lenOfX = 1; lenOfX < str.length(); lenOfX++) {\n        double lenOfY =\n            ((double) str.length() - (double) lenOfX * (double) counts.get('x'))\n                / (double) counts.get('y');\n        if (lenOfY <= 0 || lenOfY % 1 != 0) {\n          continue;\n        }\n        int yIdx = firstYPos * lenOfX;\n        String x = str.substring(0, lenOfX);\n        String y = str.substring(yIdx, yIdx + (int) lenOfY);\n        String potentialMatch = buildPotentialMatch(newPattern, x, y);\n        if (str.equals(potentialMatch)) {\n          return didSwitch ? new String[] {y, x} : new String[] {x, y};\n        }\n      }\n    } else {\n      double lenOfX = str.length() / counts.get('x');\n      if (lenOfX % 1 == 0) {\n        String x = str.substring(0, (int) lenOfX);\n        String potentialMatch = buildPotentialMatch(newPattern, x, \"\");\n        if (str.equals(potentialMatch)) {\n          return didSwitch ? new String[] {\"\", x} : new String[] {x, \"\"};\n        }\n      }\n    }\n    return new String[] {};\n  }\n\n  public static char[] getNewPattern(String pattern) {\n    char[] patternLetters = pattern.toCharArray();\n    if (pattern.charAt(0) == 'x') {\n      return patternLetters;\n    }\n    for (int i = 0; i < patternLetters.length; i++) {\n      if (patternLetters[i] == 'x') {\n        patternLetters[i] = 'y';\n      } else {\n        patternLetters[i] = 'x';\n      }\n    }\n    return patternLetters;\n  }\n\n  public static int getCountsAndFirstYPos(char[] pattern, Map<Character, Integer> counts) {\n    int firstYPos = -1;\n    for (int i = 0; i < pattern.length; i++) {\n      char c = pattern[i];\n      counts.put(c, counts.get(c) + 1);\n      if (c == 'y' && firstYPos == -1) {\n        firstYPos = i;\n      }\n    }\n    return firstYPos;\n  }\n\n  public static String buildPotentialMatch(char[] pattern, String x, String y) {\n    StringBuilder potentialMatch = new StringBuilder();\n    for (char c : pattern) {\n      if (c == 'x') {\n        potentialMatch.append(x);\n      } else {\n        potentialMatch.append(y);\n      }\n    }\n    return potentialMatch.toString();\n  }\n}\n"
      ]
    },
    "javascript": {
      "Language": "javascript",
      "StartingCode": "function patternMatcher(pattern, string) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.patternMatcher = patternMatcher;\n",
      "StartingTest": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.patternMatcher('xyxy', 'abab')).to.deep.equal(['a', 'b']);\n});\n\nit('Test Case #2', function () {\n  chai.expect(program.patternMatcher('yxyx', 'abab')).to.deep.equal(['b', 'a']);\n});\n\nit('Test Case #3', function () {\n  chai.expect(program.patternMatcher('yxx', 'yomama')).to.deep.equal(['ma', 'yo']);\n});\n\nit('Test Case #4', function () {\n  chai.expect(program.patternMatcher('xxyxxy', 'gogopowerrangergogopowerranger')).to.deep.equal(['go', 'powerranger']);\n});\n\nit('Test Case #5', function () {\n  chai.expect(program.patternMatcher('yyxyyx', 'gogopowerrangergogopowerranger')).to.deep.equal(['powerranger', 'go']);\n});\n\nit('Test Case #6', function () {\n  chai\n    .expect(\n      program.patternMatcher(\n        'xyxxxyyx',\n        'baddaddoombaddaddoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom',\n      ),\n    )\n    .to.deep.equal(['baddaddoom', 'baddaddoomi']);\n});\n\nit('Test Case #7', function () {\n  chai\n    .expect(\n      program.patternMatcher(\n        'yxyyyxxy',\n        'baddaddoombaddaddoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom',\n      ),\n    )\n    .to.deep.equal(['baddaddoomi', 'baddaddoom']);\n});\n\nit('Test Case #8', function () {\n  chai.expect(program.patternMatcher('xxyxyy', 'testtestwrongtestwrongtest')).to.deep.equal([]);\n});\n\nit('Test Case #9', function () {\n  chai\n    .expect(\n      program.patternMatcher(\n        'xyxxxyyx',\n        'baddaddoombaddadoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom',\n      ),\n    )\n    .to.deep.equal([]);\n});\n\nit('Test Case #10', function () {\n  chai.expect(program.patternMatcher('xyx', 'thisshouldobviouslybewrong')).to.deep.equal([]);\n});\n\nit('Test Case #11', function () {\n  chai.expect(program.patternMatcher('xxxx', 'testtesttesttest')).to.deep.equal(['test', '']);\n});\n\nit('Test Case #12', function () {\n  chai.expect(program.patternMatcher('yyyy', 'testtesttesttest')).to.deep.equal(['', 'test']);\n});\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.patternMatcher('xxyxxy', 'gogopowerrangergogopowerranger')).to.deep.equal(['go', 'powerranger']);\n});\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\n// O(n^2 + m) time | O(n + m) space\nfunction patternMatcher(pattern, string) {\n  if (pattern.length > string.length) return [];\n  const newPattern = getNewPattern(pattern);\n  const didSwitch = newPattern[0] !== pattern[0];\n  const counts = {x: 0, y: 0};\n  const firstYPos = getCountsAndFirstYPos(newPattern, counts);\n  if (counts['y'] !== 0) {\n    for (let lenOfX = 1; lenOfX < string.length; lenOfX++) {\n      const lenOfY = (string.length - lenOfX * counts['x']) / counts['y'];\n      if (lenOfY <= 0 || lenOfY % 1 !== 0) continue;\n      const yIdx = firstYPos * lenOfX;\n      const x = string.slice(0, lenOfX);\n      const y = string.slice(yIdx, yIdx + lenOfY);\n      const potentialMatch = newPattern.map(char => (char === 'x' ? x : y));\n      if (string === potentialMatch.join('')) {\n        return !didSwitch ? [x, y] : [y, x];\n      }\n    }\n  } else {\n    let lenOfX = string.length / counts['x'];\n    if (lenOfX % 1 === 0) {\n      const x = string.slice(0, lenOfX);\n      const potentialMatch = newPattern.map(char => (char === 'x' ? x : ''));\n      if (string === potentialMatch.join('')) {\n        return !didSwitch ? [x, ''] : ['', x];\n      }\n    }\n  }\n  return [];\n}\n\nfunction getNewPattern(pattern) {\n  const patternLetters = pattern.split('');\n  if (pattern[0] === 'x') {\n    return patternLetters;\n  } else {\n    return patternLetters.map(char => (char === 'y' ? 'x' : 'y'));\n  }\n}\n\nfunction getCountsAndFirstYPos(pattern, counts) {\n  let firstYPos = null;\n  for (let i = 0; i < pattern.length; i++) {\n    const char = pattern[i];\n    counts[char]++;\n    if (char === 'y' && firstYPos === null) firstYPos = i;\n  }\n  return firstYPos;\n}\n\nexports.patternMatcher = patternMatcher;\n"
      ]
    },
    "python": {
      "Language": "python",
      "StartingCode": "def patternMatcher(pattern, string):\n    # Write your code here.\n    pass\n",
      "StartingTest": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.patternMatcher(\"xyxy\", \"abab\"), [\"a\", \"b\"])\n\n    def test_case_2(self):\n        self.assertEqual(program.patternMatcher(\"yxyx\", \"abab\"), [\"b\", \"a\"])\n\n    def test_case_3(self):\n        self.assertEqual(program.patternMatcher(\"yxx\", \"yomama\"), [\"ma\", \"yo\"])\n\n    def test_case_4(self):\n        self.assertEqual(program.patternMatcher(\"xxyxxy\", \"gogopowerrangergogopowerranger\"), [\"go\", \"powerranger\"])\n\n    def test_case_5(self):\n        self.assertEqual(program.patternMatcher(\"yyxyyx\", \"gogopowerrangergogopowerranger\"), [\"powerranger\", \"go\"])\n\n    def test_case_6(self):\n        self.assertEqual(\n            program.patternMatcher(\n                \"xyxxxyyx\", \"baddaddoombaddaddoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom\"\n            ),\n            [\"baddaddoom\", \"baddaddoomi\"],\n        )\n\n    def test_case_7(self):\n        self.assertEqual(\n            program.patternMatcher(\n                \"yxyyyxxy\", \"baddaddoombaddaddoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom\"\n            ),\n            [\"baddaddoomi\", \"baddaddoom\"],\n        )\n\n    def test_case_8(self):\n        self.assertEqual(program.patternMatcher(\"xxyxyy\", \"testtestwrongtestwrongtest\"), [])\n\n    def test_case_9(self):\n        self.assertEqual(\n            program.patternMatcher(\n                \"xyxxxyyx\", \"baddaddoombaddadoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom\"\n            ),\n            [],\n        )\n\n    def test_case_10(self):\n        self.assertEqual(program.patternMatcher(\"xyx\", \"thisshouldobviouslybewrong\"), [])\n\n    def test_case_11(self):\n        self.assertEqual(program.patternMatcher(\"xxxx\", \"testtesttesttest\"), [\"test\", \"\"])\n\n    def test_case_12(self):\n        self.assertEqual(program.patternMatcher(\"yyyy\", \"testtesttesttest\"), [\"\", \"test\"])\n",
      "SandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.patternMatcher(\"xxyxxy\", \"gogopowerrangergogopowerranger\"), [\"go\", \"powerranger\"])\n",
      "Solutions": [
        "# Copyright © 2020 Code Complete. All rights reserved.\n\n# O(n^2 + m) time | O(n + m) space\ndef patternMatcher(pattern, string):\n    if len(pattern) > len(string):\n        return []\n    newPattern = getNewPattern(pattern)\n    didSwitch = newPattern[0] != pattern[0]\n    counts = {\"x\": 0, \"y\": 0}\n    firstYPos = getCountsAndFirstYPos(newPattern, counts)\n    if counts[\"y\"] != 0:\n        for lenOfX in range(1, len(string)):\n            lenOfY = (len(string) - lenOfX * counts[\"x\"]) / counts[\"y\"]\n            if lenOfY <= 0 or lenOfY % 1 != 0:\n                continue\n            lenOfY = int(lenOfY)\n            yIdx = firstYPos * lenOfX\n            x = string[:lenOfX]\n            y = string[yIdx : yIdx + lenOfY]\n            potentialMatch = map(lambda char: x if char == \"x\" else y, newPattern)\n            if string == \"\".join(potentialMatch):\n                return [x, y] if not didSwitch else [y, x]\n    else:\n        lenOfX = len(string) / counts[\"x\"]\n        if lenOfX % 1 == 0:\n            lenOfX = int(lenOfX)\n            x = string[:lenOfX]\n            potentialMatch = map(lambda char: x, newPattern)\n            if string == \"\".join(potentialMatch):\n                return [x, \"\"] if not didSwitch else [\"\", x]\n    return []\n\n\ndef getNewPattern(pattern):\n    patternLetters = list(pattern)\n    if pattern[0] == \"x\":\n        return patternLetters\n    else:\n        return list(map(lambda char: \"x\" if char == \"y\" else \"y\", patternLetters))\n\n\ndef getCountsAndFirstYPos(pattern, counts):\n    firstYPos = None\n    for i, char in enumerate(pattern):\n        counts[char] += 1\n        if char == \"y\" and firstYPos is None:\n            firstYPos = i\n    return firstYPos\n"
      ]
    },
    "swift": {
      "Language": "swift",
      "StartingCode": "class Program {\n  func patternMatcher(_ pattern: String, _ string: String) -> [String] {\n    // Write your code here.\n    return []\n  }\n}\n",
      "StartingTest": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      try assertEqual([\"a\", \"b\"], program.patternMatcher(\"xyxy\", \"abab\"))\n    }\n    runTest(\"Test Case 2\") { () throws -> Void in\n      try assertEqual([\"b\", \"a\"], program.patternMatcher(\"yxyx\", \"abab\"))\n    }\n    runTest(\"Test Case 3\") { () throws -> Void in\n      try assertEqual([\"ma\", \"yo\"], program.patternMatcher(\"yxx\", \"yomama\"))\n    }\n    runTest(\"Test Case 4\") { () throws -> Void in\n      try assertEqual([\"go\", \"powerranger\"], program.patternMatcher(\"xxyxxy\", \"gogopowerrangergogopowerranger\"))\n    }\n    runTest(\"Test Case 5\") { () throws -> Void in\n      try assertEqual([\"powerranger\", \"go\"], program.patternMatcher(\"yyxyyx\", \"gogopowerrangergogopowerranger\"))\n    }\n    runTest(\"Test Case 6\") { () throws -> Void in\n      try assertEqual([\"baddaddoom\", \"baddaddoomi\"], program.patternMatcher(\"xyxxxyyx\", \"baddaddoombaddaddoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom\"))\n    }\n    runTest(\"Test Case 7\") { () throws -> Void in\n      try assertEqual([\"baddaddoomi\", \"baddaddoom\"], program.patternMatcher(\"yxyyyxxy\", \"baddaddoombaddaddoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom\"))\n    }\n    runTest(\"Test Case 8\") { () throws -> Void in\n      try assertEqual([], program.patternMatcher(\"xxyxyy\", \"testtestwrongtestwrongtest\"))\n    }\n    runTest(\"Test Case 9\") { () throws -> Void in\n      try assertEqual([], program.patternMatcher(\"xyxxxyyx\", \"baddaddoombaddadoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom\"))\n    }\n    runTest(\"Test Case 10\") { () throws -> Void in\n      try assertEqual([], program.patternMatcher(\"xyx\", \"thisshouldobviouslybewrong\"))\n    }\n    runTest(\"Test Case 11\") { () throws -> Void in\n      try assertEqual([\"test\", \"\"], program.patternMatcher(\"xxxx\", \"testtesttesttest\"))\n    }\n    runTest(\"Test Case 12\") { () throws -> Void in\n      try assertEqual([\"\", \"test\"], program.patternMatcher(\"yyyy\", \"testtesttesttest\"))\n    }\n  }\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      try assertEqual([\"go\", \"powerranger\"], program.patternMatcher(\"xxyxxy\", \"gogopowerrangergogopowerranger\"))\n    }\n  }\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nclass Program {\n  // O(n ^ 2 + m) time | O(n + m) space\n  func patternMatcher(_ pattern: String, _ string: String) -> [String] {\n    if pattern.count > string.count {\n      return []\n    }\n\n    let oldPattern = pattern.map { String($0) }\n    let newPattern = generateNewPattern(pattern)\n    let didSwitch = oldPattern[0] != newPattern[0]\n\n    var counts = [\"x\": 0, \"y\": 0]\n    let firstYPosition = populateCountsAndGetFirstYPosition(&counts, newPattern)\n\n    if counts[\"y\"] != 0 {\n      for lengthOfX in 1 ..< string.count {\n        if let countsOfX = counts[\"x\"], let countsOfY = counts[\"y\"] {\n          let lengthOfY: Double = Double(string.count - (lengthOfX * countsOfX)) / Double(countsOfY)\n\n          if lengthOfY <= 0 || lengthOfY.truncatingRemainder(dividingBy: 1) != 0 {\n            continue\n          }\n\n          let indexOfY = lengthOfX * firstYPosition\n\n          let startX = string.index(string.startIndex, offsetBy: 0)\n          let endX = string.index(string.startIndex, offsetBy: lengthOfX)\n          let x = String(string[startX ..< endX])\n\n          let startY = string.index(string.startIndex, offsetBy: indexOfY)\n          let endY = string.index(string.startIndex, offsetBy: indexOfY + Int(lengthOfY))\n          let y = String(string[startY ..< endY])\n\n          let potentialMatch = newPattern.map { $0 == \"x\" ? x : y }.joined(separator: \"\")\n\n          if string == potentialMatch {\n            if didSwitch {\n              return [y, x]\n            } else {\n              return [x, y]\n            }\n          }\n        }\n      }\n    } else {\n      if let countsOfX = counts[\"x\"] {\n        let lengthOfX = string.count / countsOfX\n        let startX = string.index(string.startIndex, offsetBy: 0)\n        let endX = string.index(string.startIndex, offsetBy: lengthOfX)\n        let x = String(string[startX ..< endX])\n\n        let potentialMatch = newPattern.map { $0 == \"x\" ? x : \"\" }.joined(separator: \"\")\n\n        if string == potentialMatch {\n          if didSwitch {\n            return [\"\", x]\n          } else {\n            return [x, \"\"]\n          }\n        }\n      }\n    }\n\n    return []\n  }\n\n  func generateNewPattern(_ pattern: String) -> [String] {\n    let patternCharacters = Array(pattern)\n\n    if patternCharacters[0] == \"x\" {\n      return patternCharacters.map { String($0) }\n    } else {\n      return patternCharacters.map { $0 == \"x\" ? \"y\" : \"x\" }\n    }\n  }\n\n  func populateCountsAndGetFirstYPosition(_ counts: inout [String: Int], _ newPattern: [String]) -> Int {\n    var firstYPosition = -1\n\n    for (index, currentPatternCharacter) in newPattern.enumerated() {\n      if var countPerCharacter = counts[currentPatternCharacter] {\n        countPerCharacter += 1\n        counts[currentPatternCharacter] = countPerCharacter\n      }\n\n      if currentPatternCharacter == \"y\", firstYPosition == -1 {\n        firstYPosition = index\n      }\n    }\n\n    return firstYPosition\n  }\n}\n"
      ]
    },
    "typescript": {
      "Language": "typescript",
      "StartingCode": "export function patternMatcher(pattern: string, string: string) {\n  // Write your code here.\n  return [''];\n}\n",
      "StartingTest": "",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.patternMatcher('xxyxxy', 'gogopowerrangergogopowerranger')).to.deep.equal(['go', 'powerranger']);\n});\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\ninterface Counts {\n  [key: string]: number;\n}\n\n// O(n^2 + m) time | O(n + m) space\nexport function patternMatcher(pattern: string, string: string) {\n  if (pattern.length > string.length) return [];\n  const newPattern = getNewPattern(pattern);\n  const didSwitch = newPattern[0] !== pattern[0];\n  const counts: Counts = {x: 0, y: 0};\n  const firstYPos = getCountsAndFirstYPos(newPattern, counts)!;\n  if (counts['y'] !== 0) {\n    for (let lenOfX = 1; lenOfX < string.length; lenOfX++) {\n      const lenOfY = (string.length - lenOfX * counts['x']) / counts['y'];\n      if (lenOfY <= 0 || lenOfY % 1 !== 0) continue;\n      const yIdx = firstYPos * lenOfX;\n      const x = string.slice(0, lenOfX);\n      const y = string.slice(yIdx, yIdx + lenOfY);\n      const potentialMatch = newPattern.map(char => (char === 'x' ? x : y));\n      if (string === potentialMatch.join('')) {\n        return !didSwitch ? [x, y] : [y, x];\n      }\n    }\n  } else {\n    let lenOfX = string.length / counts['x'];\n    if (lenOfX % 1 === 0) {\n      const x = string.slice(0, lenOfX);\n      const potentialMatch = newPattern.map(char => (char === 'x' ? x : ''));\n      if (string === potentialMatch.join('')) {\n        return !didSwitch ? [x, ''] : ['', x];\n      }\n    }\n  }\n  return [];\n}\n\nfunction getNewPattern(pattern: string) {\n  const patternLetters = pattern.split('');\n  if (pattern[0] === 'x') {\n    return patternLetters;\n  } else {\n    return patternLetters.map(char => (char === 'y' ? 'x' : 'y'));\n  }\n}\n\nfunction getCountsAndFirstYPos(pattern: string[], counts: Counts) {\n  let firstYPos: number | null = null;\n  for (let i = 0; i < pattern.length; i++) {\n    const char = pattern[i];\n    counts[char]++;\n    if (char === 'y' && firstYPos === null) firstYPos = i;\n  }\n  return firstYPos;\n}\n"
      ]
    }
  },
  "JSONTestLanguages": [
    "javascript",
    "cpp",
    "python",
    "java",
    "csharp",
    "go",
    "swift",
    "typescript"
  ],
  "JSONTests": [
    {
      "pattern": "xxyxxy",
      "string": "gogopowerrangergogopowerranger"
    },
    {
      "pattern": "xyxy",
      "string": "abab"
    },
    {
      "pattern": "yxyx",
      "string": "abab"
    },
    {
      "pattern": "yxx",
      "string": "yomama"
    },
    {
      "pattern": "yyxyyx",
      "string": "gogopowerrangergogopowerranger"
    },
    {
      "pattern": "xyx",
      "string": "thisshouldobviouslybewrong"
    },
    {
      "pattern": "xxxx",
      "string": "testtesttesttest"
    },
    {
      "pattern": "yyyy",
      "string": "testtesttesttest"
    },
    {
      "pattern": "xxyxyy",
      "string": "testtestwrongtestwrongtest"
    },
    {
      "pattern": "xyxxxyyx",
      "string": "baddaddoombaddadoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom"
    },
    {
      "pattern": "yxyyyxxy",
      "string": "baddaddoombaddaddoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom"
    },
    {
      "pattern": "xyxxxyyx",
      "string": "baddaddoombaddaddoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom"
    }
  ],
  "JSONAnswers": [
    [
      [
        "go",
        "powerranger"
      ],
      [
        "a",
        "b"
      ],
      [
        "b",
        "a"
      ],
      [
        "ma",
        "yo"
      ],
      [
        "powerranger",
        "go"
      ],
      [],
      [
        "test",
        ""
      ],
      [
        "",
        "test"
      ],
      [],
      [],
      [
        "baddaddoomi",
        "baddaddoom"
      ],
      [
        "baddaddoom",
        "baddaddoomi"
      ]
    ]
  ]
}