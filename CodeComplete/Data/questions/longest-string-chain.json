{
  "Summary": {
    "Name": "Longest String Chain",
    "Category": "Dynamic Programming",
    "Difficulty": 4,
    "Available": true,
    "Metadata": {
      "date": "2019-11-21T00:00:00Z",
      "number": 665,
      "timeOne": 0,
      "timeTwo": 1655,
      "url": "https://player.vimeo.com/video/374201798"
    }
  },
  "Prompt": "",
  "Hints": "For each string, you will have to remove every letter one at a time to see if the resulting strings are contained in the input list of strings. What data structure lends itself to quickly checking if these strings are located in the list of input strings?\nRealize that every string in the input list of strings potentially has a string chain (and therefore a longest string chain) that starts with itself. Compute all of these string chains and store them so that you don't have to compute them more than once.\nSort the input list of strings (from shortest to longest string) in order to simplify the problem. Iterate through the list of sorted strings, and for each string, compute the longest string chain that starts with itself. To do so, try removing every letter from each string and seeing if the resulting strings are in the input list of strings; you can do so in constant time by dumping every string in a hash table. In the hash table, store the longest string chain of every string as you compute them. As you iterate through longer strings, whenever you find a shorter string for which you've already computed the longest string chain, you can very quickly append the longer string to that already-computed string chain. Do this for every string, and you'll eventually find the longest string chain that you're looking for.\nDo you need to store every string's longest string chain mentioned in Hint #3, or can you store less information per string so as to take up less auxiliary space?",
  "SpaceTime": "O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings and m is the length of the longest string",
  "PromptHTML": "<p>\n  Given a list of strings, write a function that returns the longest string\n  chain that can be built from those strings.\n</p>\n<p>\n  A string chain is defined as follows: let string <span>A</span> be a string in\n  the initial array; if removing any single character from string\n  <span>A</span> yields a new string <span>B</span> that's contained in the\n  initial array of strings, then strings <span>A</span> and <span>B</span> form\n  a string chain of length 2. Similarly, if removing any single character from\n  string <span>B</span> yields a new string <span>C</span> that's contained in\n  the initial array of strings, then strings <span>A</span>, <span>B</span>, and\n  <span>C</span> form a string chain of length 3.\n</p>\n<p>\n  The function should return the string chain in descending order (i.e., from\n  the longest string to the shortest one). Note that string chains of length 1\n  don't exist; if the list of strings doesn't contain any string chain formed by\n  two or more strings, the function should return an empty array.\n</p>\n<p>\n  You can assume that there will only be one longest string chain.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">strings</span> = [\"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\"]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\"]\n</pre>\n",
  "Notes": "",
  "IsLongOutput": false,
  "Visualization": {
    "inputType": null,
    "outputType": null
  },
  "CustomInputLanguages": [
    "javascript",
    "cpp",
    "python",
    "java",
    "csharp",
    "go",
    "swift",
    "typescript"
  ],
  "CustomInputVars": [
    {
      "Name": "strings",
      "Example": [
        "abde",
        "abc",
        "abd",
        "abcde",
        "ade",
        "ae",
        "1abde",
        "abcdef"
      ],
      "Schema": {
        "items": {
          "type": "string"
        },
        "type": "array"
      }
    }
  ],
  "Resources": {
    "cpp": {
      "Language": "cpp",
      "StartingCode": "#include <vector>\n\nusing namespace std;\n\nvector<string> longestStringChain(vector<string> strings) {\n  // Write your code here.\n  return {};\n}\n",
      "StartingTest": "class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n\n    RunTest(\"Test Case 1\", []() {\n      vector<string> strings = {\"abcdefg\", \"abcdef\", \"abcde\", \"abcd\",\n                                \"abc\",     \"ab\",     \"a\"};\n      vector<string> expected = {\"abcdefg\", \"abcdef\", \"abcde\", \"abcd\",\n                                 \"abc\",     \"ab\",     \"a\"};\n      assert(longestStringChain(strings) == expected);\n    });\n\n    RunTest(\"Test Case 2\", []() {\n      vector<string> strings = {\"abcdefg\", \"abdefg\", \"abdfg\", \"bdfg\",\n                                \"bfg\",     \"bg\",     \"g\"};\n      vector<string> expected = {\"abcdefg\", \"abdefg\", \"abdfg\", \"bdfg\",\n                                 \"bfg\",     \"bg\",     \"g\"};\n      assert(longestStringChain(strings) == expected);\n    });\n\n    RunTest(\"Test Case 3\", []() {\n      vector<string> strings = {\"abcdefg\", \"1234\", \"abdefg\", \"abdfg\", \"123\",\n                                \"12\",      \"bg\",   \"g\",      \"12345\", \"12a345\"};\n      vector<string> expected = {\"12a345\", \"12345\", \"1234\", \"123\", \"12\"};\n\n      assert(longestStringChain(strings) == expected);\n    });\n\n    RunTest(\"Test Case 4\", []() {\n      vector<string> strings = {\"abcdefg1\", \"1234c\", \"abdefg2\", \"abdfg\",\n                                \"123\",      \"122\",   \"bgg\",     \"g\",\n                                \"1a2345\",   \"12a345\"};\n      vector<string> expected = {};\n      assert(longestStringChain(strings) == expected);\n    });\n\n    RunTest(\"Test Case 5\", []() {\n      vector<string> strings = {\"abde\", \"abc\", \"abd\",   \"abcde\",\n                                \"ade\",  \"ae\",  \"1abde\", \"abcdef\"};\n      vector<string> expected = {\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\"};\n      assert(longestStringChain(strings) == expected);\n    });\n\n    RunTest(\"Test Case 6\", []() {\n      vector<string> strings = {\n          \"lgoprt\",    \"12345678\", \"algoxpert\", \"abcde\",   \"123468\",\n          \"lgoxprt\",   \"abde\",     \"lgopt\",     \"1234678\", \"ade\",\n          \"ae\",        \"algoxprt\", \"a\",         \"1abde\",   \"lgpt\",\n          \"123456789\", \"234678\",   \"codecomplete\"};\n      vector<string> expected = {\"codecomplete\", \"algoxpert\", \"algoxprt\",\n                                 \"lgoxprt\",    \"lgoprt\",    \"lgopt\",\n                                 \"lgpt\"};\n      assert(longestStringChain(strings) == expected);\n    });\n\n    RunTest(\"Test Case 7\", []() {\n      vector<string> strings = {\"12345678\", \"algoxpert\", \"123468\", \"abde\",\n                                \"lgopt\",    \"1234678\",   \"ade\",    \"ae\",\n                                \"a\",        \"1abde\",     \"lgpt\",   \"123456789\",\n                                \"234678\",   \"codecomplete\"};\n      vector<string> expected = {\"1abde\", \"abde\", \"ade\", \"ae\", \"a\"};\n      assert(longestStringChain(strings) == expected);\n    });\n  }\n};\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<string> strings = {\"abde\", \"abc\", \"abd\",   \"abcde\",\n                                \"ade\",  \"ae\",  \"1abde\", \"abcdef\"};\n      vector<string> expected = {\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\"};\n      assert(longestStringChain(strings) == expected);\n    });\n  }\n};\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\n\nstruct stringChain {\n  string nextString;\n  int maxChainLength;\n};\n\nvoid findLongestStringChain(string str,\n                            unordered_map<string, stringChain> &stringChains);\nstring getSmallerString(string str, int index);\nvoid tryUpdateLongestStringChain(\n    string currentString, string smallerString,\n    unordered_map<string, stringChain> &stringChains);\nvector<string>\nbuildLongestStringChain(vector<string> strings,\n                        unordered_map<string, stringChain> stringChains);\n\n// O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings\n// and m is the length of the longest string\nvector<string> longestStringChain(vector<string> strings) {\n  // For every string, imagine the longest string chain that starts with it.\n  // Set up every string to point to the next string in its respective longest\n  // string chain. Also keep track of the lengths of these longest string\n  // chains.\n  unordered_map<string, stringChain> stringChains = {};\n  for (auto string : strings) {\n    stringChains[string] = {\"\", 1};\n  }\n\n  // Sort the strings based on their length so that whenever we visit a\n  // string (as we iterate through them from left to right), we can\n  // already have computed the longest string chains of any smaller strings.\n  vector<string> sortedStrings = strings;\n  sort(sortedStrings.begin(), sortedStrings.end(),\n       [](string a, string b) -> bool { return a.size() < b.size(); });\n\n  for (auto string : sortedStrings) {\n    findLongestStringChain(string, stringChains);\n  }\n\n  return buildLongestStringChain(strings, stringChains);\n}\n\nvoid findLongestStringChain(string str,\n                            unordered_map<string, stringChain> &stringChains) {\n  // Try removing every letter of the current string to see if the\n  // remaining strings form a string chain.\n  for (int i = 0; i < str.size(); i++) {\n    string smallerString = getSmallerString(str, i);\n    if (stringChains.find(smallerString) == stringChains.end())\n      continue;\n    tryUpdateLongestStringChain(str, smallerString, stringChains);\n  }\n}\n\nstring getSmallerString(string str, int index) {\n  return str.substr(0, index) + str.substr(index + 1);\n}\n\nvoid tryUpdateLongestStringChain(\n    string currentString, string smallerString,\n    unordered_map<string, stringChain> &stringChains) {\n  int smallerStringChainLength = stringChains[smallerString].maxChainLength;\n  int currentStringChainLength = stringChains[currentString].maxChainLength;\n  // Update the string chain of the current string only if the smaller string\n  // leads to a longer string chain.\n  if (smallerStringChainLength + 1 > currentStringChainLength) {\n    stringChains[currentString].maxChainLength = smallerStringChainLength + 1;\n    stringChains[currentString].nextString = smallerString;\n  }\n}\n\nvector<string>\nbuildLongestStringChain(vector<string> strings,\n                        unordered_map<string, stringChain> stringChains) {\n  // Find the string that starts the longest string chain.\n  int maxChainLength = 0;\n  string chainStartingString = \"\";\n  for (auto string : strings) {\n    if (stringChains[string].maxChainLength > maxChainLength) {\n      maxChainLength = stringChains[string].maxChainLength;\n      chainStartingString = string;\n    }\n  }\n\n  // Starting at the string found above, build the longest string chain.\n  vector<string> ourLongestStringChain;\n  string currentString = chainStartingString;\n  while (currentString != \"\") {\n    ourLongestStringChain.push_back(currentString);\n    currentString = stringChains[currentString].nextString;\n  }\n\n  return ourLongestStringChain.size() == 1 ? vector<string>{}\n                                           : ourLongestStringChain;\n}"
      ]
    },
    "csharp": {
      "Language": "csharp",
      "StartingCode": "using System.Collections.Generic;\n\npublic class Program {\n\tpublic static List<string> longeststringChain(List<string> strings) {\n\t\t// Write your code here.\n\t\treturn null;\n\t}\n}\n",
      "StartingTest": "using System.Linq;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tList<string> strings = new List<string>(new [] {\"abcdefg\", \"abcdef\", \"abcde\",\n\t\t                                                \"abcd\",\n\t\t                                                \"abc\",         \"ab\",         \"a\"});\n\t\tList<string> expected = new List<string>(new [] {\"abcdefg\", \"abcdef\", \"abcde\",\n\t\t                                                 \"abcd\",\n\t\t                                                 \"abc\",         \"ab\",         \"a\"});\n\t\tUtils.AssertTrue(Program.longeststringChain(strings).SequenceEqual(expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase2() {\n\t\tList<string> strings = new List<string>(new [] {\"abcdefg\", \"abdefg\", \"abdfg\",\n\t\t                                                \"bdfg\",\n\t\t                                                \"bfg\",         \"bg\",         \"g\"});\n\t\tList<string> expected = new List<string>(new [] {\"abcdefg\", \"abdefg\", \"abdfg\",\n\t\t                                                 \"bdfg\",\n\t\t                                                 \"bfg\",         \"bg\",         \"g\"});\n\t\tUtils.AssertTrue(Program.longeststringChain(strings).SequenceEqual(expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase3() {\n\t\tList<string> strings = new List<string>(new [] {\"abcdefg\", \"1234\", \"abdefg\",\n\t\t                                                \"abdfg\", \"123\",\n\t\t                                                \"12\",            \"bg\",     \"g\",\n\t\t                                                \"12345\", \"12a345\"});\n\t\tList<string> expected = new List<string>(){\n\t\t\t\"12a345\", \"12345\", \"1234\", \"123\", \"12\"\n\t\t};\n\t\tUtils.AssertTrue(Program.longeststringChain(strings).SequenceEqual(expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase4() {\n\t\tList<string> strings = new List<string>(new [] {\"abcdefg1\", \"1234c\", \"abdefg2\",\n\t\t                                                \"abdfg\",\n\t\t                                                \"123\",            \"122\",     \"bgg\",\n\t\t                                                \"g\",\n\t\t                                                \"1a2345\",     \"12a345\"});\n\t\tList<string> expected = new List<string>();\n\t\tUtils.AssertTrue(Program.longeststringChain(strings).SequenceEqual(expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase5() {\n\t\tList<string> strings = new List<string>(new [] {\"abde\", \"abc\", \"abd\",     \"abcde\",\n\t\t                                                \"ade\",    \"ae\",    \"1abde\",\n\t\t                                                \"abcdef\"});\n\t\tList<string> expected = new List<string>(){\n\t\t\t\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\"\n\t\t};\n\t\tUtils.AssertTrue(Program.longeststringChain(strings).SequenceEqual(expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase6() {\n\t\tList<string> strings = new List<string>(new [] {\"lgoprt\", \"12345678\", \"algoxpert\",\n\t\t                                                \"abcde\",         \"123468\",\n\t\t                                                \"lgoxprt\",\n\t\t                                                \"abde\",     \"lgopt\",\n\t\t                                                \"1234678\",     \"ade\",\n\t\t                                                \"ae\",\n\t\t                                                \"algoxprt\",\n\t\t                                                \"a\",            \"1abde\",\n\t\t                                                \"lgpt\",            \"123456789\",\n\t\t                                                \"234678\",\n\t\t                                                \"codecomplete\"});\n\t\tList<string> expected = new List<string>(new [] {\"codecomplete\", \"algoxpert\",\n\t\t                                                 \"algoxprt\", \"lgoxprt\",\n\t\t                                                 \"lgoprt\",         \"lgopt\",\n\t\t                                                 \"lgpt\"});\n\t\tUtils.AssertTrue(Program.longeststringChain(strings).SequenceEqual(expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase7() {\n\t\tList<string> strings = new List<string>(new [] {\"12345678\", \"algoxpert\", \"123468\",\n\t\t                                                \"abde\",\n\t\t                                                \"lgopt\",        \"1234678\",\n\t\t                                                \"ade\",        \"ae\",\n\t\t                                                \"a\",                \"1abde\",\n\t\t                                                \"lgpt\",     \"123456789\",\n\t\t                                                \"234678\",     \"codecomplete\"});\n\t\tList<string> expected = new List<string>(){\n\t\t\t\"1abde\", \"abde\", \"ade\", \"ae\", \"a\"\n\t\t};\n\t\tUtils.AssertTrue(Program.longeststringChain(strings).SequenceEqual(expected));\n\t}\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tList<string> strings = new List<string>(new [] {\"abde\", \"abc\", \"abd\",     \"abcde\",\n\t\t                                                \"ade\",    \"ae\",    \"1abde\",\n\t\t                                                \"abcdef\"});\n\t\tList<string> expected = new List<string>(){\n\t\t\t\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\"\n\t\t};\n\t\tUtils.AssertTrue(Program.longeststringChain(strings).SequenceEqual(expected));\n\t}\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n\n\tpublic class stringChain {\n\t\tpublic string nextstring;\n\t\tpublic int maxChainLength;\n\n\t\tpublic stringChain(string nextstring, int maxChainLength) {\n\t\t\tthis.nextstring = nextstring;\n\t\t\tthis.maxChainLength = maxChainLength;\n\t\t}\n\t}\n\n\t// O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings\n\t// and m is the length of the longest string\n\tpublic static List<string> longeststringChain(List<string> strings) {\n\t\t// For every string, imagine the longest string chain that starts with it.\n\t\t// Set up every string to point to the next string in its respective longest\n\t\t// string chain. Also keep track of the lengths of these longest string\n\t\t// chains.\n\t\tDictionary<string,\n\t\t  stringChain> stringChains = new Dictionary<string, stringChain>();\n\t\tforeach (string str in strings) {\n\t\t\tstringChains[str] = new stringChain(\"\", 1);\n\t\t}\n\n\t\t// Sort the strings based on their length so that whenever we visit a\n\t\t// string (as we iterate through them from left to right), we can\n\t\t// already have computed the longest string chains of any smaller strings.\n\t\tList<string> sortedstrings = new List<string>(strings);\n\t\tsortedstrings.Sort((a, b) => a.Length - b.Length);\n\n\t\tforeach (string str in sortedstrings) {\n\t\t\tfindLongeststringChain(str, stringChains);\n\t\t}\n\n\t\treturn buildLongeststringChain(strings, stringChains);\n\t}\n\n\tpublic static void findLongeststringChain(string str, Dictionary<string,\n\t  stringChain> stringChains) {\n\t\t// Try removing every letter of the current string to see if the\n\t\t// remaining strings form a string chain.\n\t\tfor (int i = 0; i < str.Length; i++) {\n\t\t\tstring smallerstring = getSmallerstring(str, i);\n\t\t\tif (!stringChains.ContainsKey(smallerstring)) continue;\n\t\t\ttryUpdateLongeststringChain(str, smallerstring, stringChains);\n\t\t}\n\t}\n\n\tpublic static string getSmallerstring(string str, int index) {\n\t\treturn str.Substring(0, index) + str.Substring(index + 1);\n\t}\n\n\tpublic static void tryUpdateLongeststringChain(\n\t\tstring currentstring,\n\t\tstring smallerstring,\n\t\tDictionary<string, stringChain> stringChains\n\t\t) {\n\t\tint smallerstringChainLength = stringChains[smallerstring].maxChainLength;\n\t\tint currentstringChainLength = stringChains[currentstring].maxChainLength;\n\t\t// Update the string chain of the current string only if the smaller string\n\t\t// leads to a longer string chain.\n\t\tif (smallerstringChainLength + 1 > currentstringChainLength) {\n\t\t\tstringChains[currentstring].maxChainLength = smallerstringChainLength + 1;\n\t\t\tstringChains[currentstring].nextstring = smallerstring;\n\t\t}\n\t}\n\n\tpublic static List<string> buildLongeststringChain(List<string> strings, Dictionary<string,\n\t  stringChain> stringChains) {\n\t\t// Find the string that starts the longest string chain.\n\t\tint maxChainLength = 0;\n\t\tstring chainStartingstring = \"\";\n\t\tforeach (string str in strings) {\n\t\t\tif (stringChains[str].maxChainLength > maxChainLength) {\n\t\t\t\tmaxChainLength = stringChains[str].maxChainLength;\n\t\t\t\tchainStartingstring = str;\n\t\t\t}\n\t\t}\n\n\t\t// Starting at the string found above, build the longest string chain.\n\t\tList<string> ourLongeststringChain = new List<string>();\n\t\tstring currentstring = chainStartingstring;\n\t\twhile (currentstring != \"\") {\n\t\t\tourLongeststringChain.Add(currentstring);\n\t\t\tcurrentstring = stringChains[currentstring].nextstring;\n\t\t}\n\n\t\treturn ourLongeststringChain.Count ==\n\t\t       1 ? new List<string>() : ourLongeststringChain;\n\t}\n}\n"
      ]
    },
    "go": {
      "Language": "go",
      "StartingCode": "package main\n\nfunc LonguestStringChain(strings []string) []string {\n\t// Write your code here.\n\treturn nil\n}\n",
      "StartingTest": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := []string{\"abcdefg\", \"abcdef\", \"abcde\", \"abcd\", \"abc\", \"ab\", \"a\"}\n\texpected := []string{\"abcdefg\", \"abcdef\", \"abcde\", \"abcd\", \"abc\", \"ab\", \"a\"}\n\toutput := LonguestStringChain(input)\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase2(t *TestCase) {\n\tinput := []string{\"abcdefg\", \"abdefg\", \"abdfg\", \"bdfg\", \"bfg\", \"bg\", \"g\"}\n\texpected := []string{\"abcdefg\", \"abdefg\", \"abdfg\", \"bdfg\", \"bfg\", \"bg\", \"g\"}\n\toutput := LonguestStringChain(input)\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase3(t *TestCase) {\n\tinput := []string{\n\t\t\"abcdefg\",\n\t\t\"1234\",\n\t\t\"abdefg\",\n\t\t\"abdfg\",\n\t\t\"123\",\n\t\t\"12\",\n\t\t\"bg\",\n\t\t\"g\",\n\t\t\"12345\",\n\t\t\"12a345\",\n\t}\n\texpected := []string{\"12a345\", \"12345\", \"1234\", \"123\", \"12\"}\n\toutput := LonguestStringChain(input)\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase4(t *TestCase) {\n\tinput := []string{\n\t\t\"abcdefg1\",\n\t\t\"1234c\",\n\t\t\"abdefg2\",\n\t\t\"abdfg\",\n\t\t\"123\",\n\t\t\"122\",\n\t\t\"bgg\",\n\t\t\"g\",\n\t\t\"1a2345\",\n\t\t\"12a345\",\n\t}\n\texpected := []string{}\n\toutput := LonguestStringChain(input)\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase5(t *TestCase) {\n\tinput := []string{\"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\"}\n\texpected := []string{\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\"}\n\toutput := LonguestStringChain(input)\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase6(t *TestCase) {\n\tinput := []string{\n\t\t\"lgoprt\",\n\t\t\"12345678\",\n\t\t\"algoxpert\",\n\t\t\"abcde\",\n\t\t\"123468\",\n\t\t\"lgoxprt\",\n\t\t\"abde\",\n\t\t\"lgopt\",\n\t\t\"1234678\",\n\t\t\"ade\",\n\t\t\"ae\",\n\t\t\"algoxprt\",\n\t\t\"a\",\n\t\t\"1abde\",\n\t\t\"lgpt\",\n\t\t\"123456789\",\n\t\t\"234678\",\n\t\t\"codecomplete\",\n\t}\n\texpected := []string{\n\t\t\"codecomplete\",\n\t\t\"algoxpert\",\n\t\t\"algoxprt\",\n\t\t\"lgoxprt\",\n\t\t\"lgoprt\",\n\t\t\"lgopt\",\n\t\t\"lgpt\",\n\t}\n\toutput := LonguestStringChain(input)\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase7(t *TestCase) {\n\tinput := []string{\n\t\t\"12345678\",\n\t\t\"algoxpert\",\n\t\t\"123468\",\n\t\t\"abde\",\n\t\t\"lgopt\",\n\t\t\"1234678\",\n\t\t\"ade\",\n\t\t\"ae\",\n\t\t\"a\",\n\t\t\"1abde\",\n\t\t\"lgpt\",\n\t\t\"123456789\",\n\t\t\"234678\",\n\t\t\"codecomplete\",\n\t}\n\texpected := []string{\"1abde\", \"abde\", \"ade\", \"ae\", \"a\"}\n\toutput := LonguestStringChain(input)\n\trequire.Equal(t, expected, output)\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := []string{\"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\"}\n\texpected := []string{\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\"}\n\toutput := LonguestStringChain(input)\n\trequire.Equal(t, expected, output)\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\npackage main\n\nimport (\n\t\"sort\"\n)\n\ntype Chain struct {\n\tNextString     string\n\tMaxChainLength int\n}\n\n// O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings and\n// m is the length of the longest string\nfunc LonguestStringChain(strings []string) []string {\n\t// For every string, imagine the longest string chain that starts with it.\n\t// Set up every string to point to the next string in its respective longest\n\t// string chain. Also keep track of the lengths of these longest string chains.\n\tstringChains := map[string]*Chain{}\n\tfor _, str := range strings {\n\t\tstringChains[str] = &Chain{NextString: \"\", MaxChainLength: 1}\n\t}\n\n\t// Sort the strings based on their length so that whenever we visit a\n\t// string (as we iterate through them from left to right), we can\n\t// already have computed the longest string chains of any smaller strings.\n\tsort.Slice(strings, func(i, j int) bool {\n\t\treturn len(strings[i]) < len(strings[j])\n\t})\n\tsortedStrings := strings\n\n\tfor _, str := range sortedStrings {\n\t\tfindLongestStringChain(str, stringChains)\n\t}\n\treturn buildLongestStringChain(strings, stringChains)\n}\n\nfunc findLongestStringChain(str string, stringChains map[string]*Chain) {\n\t// Try removing every letter of the current string to see if the\n\t// remaining strings form a string chain.\n\tfor i := range str {\n\t\tsmallerString := getSmallerString(str, i)\n\t\tif _, found := stringChains[smallerString]; !found {\n\t\t\tcontinue\n\t\t}\n\t\ttryUpdateLongestStringChain(str, smallerString, stringChains)\n\t}\n}\n\nfunc getSmallerString(str string, index int) string {\n\treturn str[:index] + str[index+1:]\n}\n\nfunc tryUpdateLongestStringChain(currentString, smallerString string, stringChains map[string]*Chain) {\n\tsmallerStringChainLength := stringChains[smallerString].MaxChainLength\n\tcurrentStringChainLength := stringChains[currentString].MaxChainLength\n\t// Update the string chain of the current string only if the smaller string leads\n\t// to a longer string chain.\n\tif smallerStringChainLength+1 > currentStringChainLength {\n\t\tstringChains[currentString].MaxChainLength = smallerStringChainLength + 1\n\t\tstringChains[currentString].NextString = smallerString\n\t}\n}\n\nfunc buildLongestStringChain(strings []string, stringChains map[string]*Chain) []string {\n\t// Find the string that starts the longest string chain.\n\tmaxChainLength := 0\n\tchainStartingString := \"\"\n\tfor _, str := range strings {\n\t\tif stringChains[str].MaxChainLength > maxChainLength {\n\t\t\tmaxChainLength = stringChains[str].MaxChainLength\n\t\t\tchainStartingString = str\n\t\t}\n\t}\n\n\t// Starting at the string found above, build the longest string chain.\n\tourLongestStringChain := []string{}\n\tcurrentString := chainStartingString\n\tfor currentString != \"\" {\n\t\tourLongestStringChain = append(ourLongestStringChain, currentString)\n\t\tcurrentString = stringChains[currentString].NextString\n\t}\n\tif len(ourLongestStringChain) == 1 {\n\t\treturn []string{}\n\t}\n\treturn ourLongestStringChain\n}\n"
      ]
    },
    "java": {
      "Language": "java",
      "StartingCode": "import java.util.*;\n\nclass Program {\n  public static List<String> longestStringChain(List<String> strings) {\n    // Write your code here.\n    return null;\n  }\n}\n",
      "StartingTest": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    List<String> strings =\n        new ArrayList<String>(\n            Arrays.asList(\"abcdefg\", \"abcdef\", \"abcde\", \"abcd\", \"abc\", \"ab\", \"a\"));\n    List<String> expected =\n        new ArrayList<String>(\n            Arrays.asList(\"abcdefg\", \"abcdef\", \"abcde\", \"abcd\", \"abc\", \"ab\", \"a\"));\n    Utils.assertTrue(Program.longestStringChain(strings).equals(expected));\n  }\n\n  @Test\n  public void TestCase2() {\n    List<String> strings =\n        new ArrayList<String>(\n            Arrays.asList(\"abcdefg\", \"abdefg\", \"abdfg\", \"bdfg\", \"bfg\", \"bg\", \"g\"));\n    List<String> expected =\n        new ArrayList<String>(\n            Arrays.asList(\"abcdefg\", \"abdefg\", \"abdfg\", \"bdfg\", \"bfg\", \"bg\", \"g\"));\n    Utils.assertTrue(Program.longestStringChain(strings).equals(expected));\n  }\n\n  @Test\n  public void TestCase3() {\n    List<String> strings =\n        new ArrayList<String>(\n            Arrays.asList(\n                \"abcdefg\", \"1234\", \"abdefg\", \"abdfg\", \"123\", \"12\", \"bg\", \"g\", \"12345\", \"12a345\"));\n    List<String> expected =\n        new ArrayList<String>(Arrays.asList(\"12a345\", \"12345\", \"1234\", \"123\", \"12\"));\n    Utils.assertTrue(Program.longestStringChain(strings).equals(expected));\n  }\n\n  @Test\n  public void TestCase4() {\n    List<String> strings =\n        new ArrayList<String>(\n            Arrays.asList(\n                \"abcdefg1\",\n                \"1234c\",\n                \"abdefg2\",\n                \"abdfg\",\n                \"123\",\n                \"122\",\n                \"bgg\",\n                \"g\",\n                \"1a2345\",\n                \"12a345\"));\n    List<String> expected = new ArrayList<String>();\n    Utils.assertTrue(Program.longestStringChain(strings).equals(expected));\n  }\n\n  @Test\n  public void TestCase5() {\n    List<String> strings =\n        new ArrayList<String>(\n            Arrays.asList(\"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\"));\n    List<String> expected =\n        new ArrayList<String>(Arrays.asList(\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\"));\n    Utils.assertTrue(Program.longestStringChain(strings).equals(expected));\n  }\n\n  @Test\n  public void TestCase6() {\n    List<String> strings =\n        new ArrayList<String>(\n            Arrays.asList(\n                \"lgoprt\",\n                \"12345678\",\n                \"algoxpert\",\n                \"abcde\",\n                \"123468\",\n                \"lgoxprt\",\n                \"abde\",\n                \"lgopt\",\n                \"1234678\",\n                \"ade\",\n                \"ae\",\n                \"algoxprt\",\n                \"a\",\n                \"1abde\",\n                \"lgpt\",\n                \"123456789\",\n                \"234678\",\n                \"codecomplete\"));\n    List<String> expected =\n        new ArrayList<String>(\n            Arrays.asList(\n                \"codecomplete\", \"algoxpert\", \"algoxprt\", \"lgoxprt\", \"lgoprt\", \"lgopt\", \"lgpt\"));\n    Utils.assertTrue(Program.longestStringChain(strings).equals(expected));\n  }\n\n  @Test\n  public void TestCase7() {\n    List<String> strings =\n        new ArrayList<String>(\n            Arrays.asList(\n                \"12345678\",\n                \"algoxpert\",\n                \"123468\",\n                \"abde\",\n                \"lgopt\",\n                \"1234678\",\n                \"ade\",\n                \"ae\",\n                \"a\",\n                \"1abde\",\n                \"lgpt\",\n                \"123456789\",\n                \"234678\",\n                \"codecomplete\"));\n    List<String> expected = new ArrayList<String>(Arrays.asList(\"1abde\", \"abde\", \"ade\", \"ae\", \"a\"));\n    Utils.assertTrue(Program.longestStringChain(strings).equals(expected));\n  }\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    List<String> strings =\n        new ArrayList<String>(\n            Arrays.asList(\"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\"));\n    List<String> expected =\n        new ArrayList<String>(Arrays.asList(\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\"));\n    Utils.assertTrue(Program.longestStringChain(strings).equals(expected));\n  }\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n\n  public static class stringChain {\n    String nextString;\n    Integer maxChainLength;\n\n    public stringChain(String nextString, Integer maxChainLength) {\n      this.nextString = nextString;\n      this.maxChainLength = maxChainLength;\n    }\n  }\n\n  // O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings\n  // and m is the length of the longest string\n  public static List<String> longestStringChain(List<String> strings) {\n    // For every string, imagine the longest string chain that starts with it.\n    // Set up every string to point to the next string in its respective longest\n    // string chain. Also keep track of the lengths of these longest string\n    // chains.\n    Map<String, stringChain> stringChains = new HashMap<String, stringChain>();\n    for (String string : strings) {\n      stringChains.put(string, new stringChain(\"\", 1));\n    }\n\n    // Sort the strings based on their length so that whenever we visit a\n    // string (as we iterate through them from left to right), we can\n    // already have computed the longest string chains of any smaller strings.\n    List<String> sortedStrings = new ArrayList<String>(strings);\n    sortedStrings.sort((a, b) -> a.length() - b.length());\n\n    for (String string : sortedStrings) {\n      findLongestStringChain(string, stringChains);\n    }\n\n    return buildLongestStringChain(strings, stringChains);\n  }\n\n  public static void findLongestStringChain(String string, Map<String, stringChain> stringChains) {\n    // Try removing every letter of the current string to see if the\n    // remaining strings form a string chain.\n    for (int i = 0; i < string.length(); i++) {\n      String smallerString = getSmallerString(string, i);\n      if (!stringChains.containsKey(smallerString)) continue;\n      tryUpdateLongestStringChain(string, smallerString, stringChains);\n    }\n  }\n\n  public static String getSmallerString(String string, int index) {\n    return string.substring(0, index) + string.substring(index + 1);\n  }\n\n  public static void tryUpdateLongestStringChain(\n      String currentString, String smallerString, Map<String, stringChain> stringChains) {\n    int smallerStringChainLength = stringChains.get(smallerString).maxChainLength;\n    int currentStringChainLength = stringChains.get(currentString).maxChainLength;\n    // Update the string chain of the current string only if the smaller string\n    // leads to a longer string chain.\n    if (smallerStringChainLength + 1 > currentStringChainLength) {\n      stringChains.get(currentString).maxChainLength = smallerStringChainLength + 1;\n      stringChains.get(currentString).nextString = smallerString;\n    }\n  }\n\n  public static List<String> buildLongestStringChain(\n      List<String> strings, Map<String, stringChain> stringChains) {\n    // Find the string that starts the longest string chain.\n    int maxChainLength = 0;\n    String chainStartingString = \"\";\n    for (String string : strings) {\n      if (stringChains.get(string).maxChainLength > maxChainLength) {\n        maxChainLength = stringChains.get(string).maxChainLength;\n        chainStartingString = string;\n      }\n    }\n\n    // Starting at the string found above, build the longest string chain.\n    List<String> ourLongestStringChain = new ArrayList<String>();\n    String currentString = chainStartingString;\n    while (currentString != \"\") {\n      ourLongestStringChain.add(currentString);\n      currentString = stringChains.get(currentString).nextString;\n    }\n\n    return ourLongestStringChain.size() == 1 ? new ArrayList<String>() : ourLongestStringChain;\n  }\n}\n"
      ]
    },
    "javascript": {
      "Language": "javascript",
      "StartingCode": "function longestStringChain(strings) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.longestStringChain = longestStringChain;\n",
      "StartingTest": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const strings = ['abcdefg', 'abcdef', 'abcde', 'abcd', 'abc', 'ab', 'a'];\n  const expected = ['abcdefg', 'abcdef', 'abcde', 'abcd', 'abc', 'ab', 'a'];\n  chai.expect(program.longestStringChain(strings)).to.deep.equal(expected);\n});\n\nit('Test Case #2', function () {\n  const strings = ['abcdefg', 'abdefg', 'abdfg', 'bdfg', 'bfg', 'bg', 'g'];\n  const expected = ['abcdefg', 'abdefg', 'abdfg', 'bdfg', 'bfg', 'bg', 'g'];\n  chai.expect(program.longestStringChain(strings)).to.deep.equal(expected);\n});\n\nit('Test Case #3', function () {\n  const strings = ['abcdefg', '1234', 'abdefg', 'abdfg', '123', '12', 'bg', 'g', '12345', '12a345'];\n  const expected = ['12a345', '12345', '1234', '123', '12'];\n  chai.expect(program.longestStringChain(strings)).to.deep.equal(expected);\n});\n\nit('Test Case #4', function () {\n  const strings = ['abcdefg1', '1234c', 'abdefg2', 'abdfg', '123', '122', 'bgg', 'g', '1a2345', '12a345'];\n  const expected = [];\n  chai.expect(program.longestStringChain(strings)).to.deep.equal(expected);\n});\n\nit('Test Case #5', function () {\n  const strings = ['abde', 'abc', 'abd', 'abcde', 'ade', 'ae', '1abde', 'abcdef'];\n  const expected = ['abcdef', 'abcde', 'abde', 'ade', 'ae'];\n  chai.expect(program.longestStringChain(strings)).to.deep.equal(expected);\n});\n\nit('Test Case #6', function () {\n  const strings = [\n    'odemplte',\n    '12345678',\n    'codecompete',\n    'abcde',\n    '123468',\n    'odecomplet',\n    'abde',\n    'compl',\n    '1234678',\n    'ade',\n    'ae',\n    'codecolete',\n    'a',\n    '1abde',\n    'lete',\n    '123456789',\n    '234678',\n    'codecomplete',\n  ];\n  const expected = ['abcde', 'abde', 'ade', 'ae', 'a'];\n chai.expect(program.longestStringChain(strings)).to.deep.equal(expected);\n});\n\nit('Test Case #7', function () {\n  const strings = [\n    '12345678',\n    'algoxpert',\n    '123468',\n    'abde',\n    'lgopt',\n    '1234678',\n    'ade',\n    'ae',\n    'a',\n    '1abde',\n    'lgpt',\n    '123456789',\n    '234678',\n    'codecomplete',\n  ];\n  const expected = ['1abde', 'abde', 'ade', 'ae', 'a'];\n  chai.expect(program.longestStringChain(strings)).to.deep.equal(expected);\n});\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const strings = ['abde', 'abc', 'abd', 'abcde', 'ade', 'ae', '1abde', 'abcdef'];\n  const expected = ['abcdef', 'abcde', 'abde', 'ade', 'ae'];\n  chai.expect(program.longestStringChain(strings)).to.deep.equal(expected);\n});\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\n// O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings and\n// m is the length of the longest string\nfunction longestStringChain(strings) {\n  // For every string, imagine the longest string chain that starts with it.\n  // Set up every string to point to the next string in its respective longest\n  // string chain. Also keep track of the lengths of these longest string chains.\n  const stringChains = {};\n  for (const string of strings) {\n    stringChains[string] = {nextString: '', maxChainLength: 1};\n  }\n\n  // Sort the strings based on their length so that whenever we visit a\n  // string (as we iterate through them from left to right), we can\n  // already have computed the longest string chains of any smaller strings.\n  const sortedStrings = strings.sort((a, b) => a.length - b.length);\n  for (const string of sortedStrings) {\n    findLongestStringChain(string, stringChains);\n  }\n\n  return buildLongestStringChain(strings, stringChains);\n}\n\nfunction findLongestStringChain(string, stringChains) {\n  // Try removing every letter of the current string to see if the\n  // remaining strings form a string chain.\n  for (let i = 0; i < string.length; i++) {\n    const smallerString = getSmallerString(string, i);\n    if (!(smallerString in stringChains)) continue;\n    tryUpdateLongestStringChain(string, smallerString, stringChains);\n  }\n}\n\nfunction getSmallerString(string, index) {\n  return string.slice(0, index) + string.slice(index + 1);\n}\n\nfunction tryUpdateLongestStringChain(currentString, smallerString, stringChains) {\n  const smallerStringChainLength = stringChains[smallerString].maxChainLength;\n  const currentStringChainLength = stringChains[currentString].maxChainLength;\n  // Update the string chain of the current string only if the smaller string leads\n  // to a longer string chain.\n  if (smallerStringChainLength + 1 > currentStringChainLength) {\n    stringChains[currentString].maxChainLength = smallerStringChainLength + 1;\n    stringChains[currentString].nextString = smallerString;\n  }\n}\n\nfunction buildLongestStringChain(strings, stringChains) {\n  // Find the string that starts the longest string chain.\n  let maxChainLength = 0;\n  let chainStartingString = '';\n  for (const string of strings) {\n    if (stringChains[string].maxChainLength > maxChainLength) {\n      maxChainLength = stringChains[string].maxChainLength;\n      chainStartingString = string;\n    }\n  }\n\n  // Starting at the string found above, build the longest string chain.\n  const ourLongestStringChain = [];\n  let currentString = chainStartingString;\n  while (currentString !== '') {\n    ourLongestStringChain.push(currentString);\n    currentString = stringChains[currentString].nextString;\n  }\n\n  return ourLongestStringChain.length === 1 ? [] : ourLongestStringChain;\n}\n\nexports.longestStringChain = longestStringChain;\n"
      ]
    },
    "python": {
      "Language": "python",
      "StartingCode": "def longestStringChain(strings):\n    # Write your code here.\n    pass\n",
      "StartingTest": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        strings = [\"abcdefg\", \"abcdef\", \"abcde\", \"abcd\", \"abc\", \"ab\", \"a\"]\n        expected = [\"abcdefg\", \"abcdef\", \"abcde\", \"abcd\", \"abc\", \"ab\", \"a\"]\n        self.assertEqual(program.longestStringChain(strings), expected)\n\n    def test_case_2(self):\n        strings = [\"abcdefg\", \"abdefg\", \"abdfg\", \"bdfg\", \"bfg\", \"bg\", \"g\"]\n        expected = [\"abcdefg\", \"abdefg\", \"abdfg\", \"bdfg\", \"bfg\", \"bg\", \"g\"]\n        self.assertEqual(program.longestStringChain(strings), expected)\n\n    def test_case_3(self):\n        strings = [\"abcdefg\", \"1234\", \"abdefg\", \"abdfg\", \"123\", \"12\", \"bg\", \"g\", \"12345\", \"12a345\"]\n        expected = [\"12a345\", \"12345\", \"1234\", \"123\", \"12\"]\n        self.assertEqual(program.longestStringChain(strings), expected)\n\n    def test_case_4(self):\n        strings = [\"abcdefg1\", \"1234c\", \"abdefg2\", \"abdfg\", \"123\", \"122\", \"bgg\", \"g\", \"1a2345\", \"12a345\"]\n        expected = []\n        self.assertEqual(program.longestStringChain(strings), expected)\n\n    def test_case_5(self):\n        strings = [\"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\"]\n        expected = [\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\"]\n        self.assertEqual(program.longestStringChain(strings), expected)\n\n    def test_case_6(self):\n        strings = [\n            \"lgoprt\",\n            \"12345678\",\n            \"algoxpert\",\n            \"abcde\",\n            \"123468\",\n            \"lgoxprt\",\n            \"abde\",\n            \"lgopt\",\n            \"1234678\",\n            \"ade\",\n            \"ae\",\n            \"algoxprt\",\n            \"a\",\n            \"1abde\",\n            \"lgpt\",\n            \"123456789\",\n            \"234678\",\n            \"codecomplete\",\n        ]\n        expected = [\"codecomplete\", \"algoxpert\", \"algoxprt\", \"lgoxprt\", \"lgoprt\", \"lgopt\", \"lgpt\"]\n        self.assertEqual(program.longestStringChain(strings), expected)\n\n    def test_case_7(self):\n        strings = [\n            \"12345678\",\n            \"algoxpert\",\n            \"123468\",\n            \"abde\",\n            \"lgopt\",\n            \"1234678\",\n            \"ade\",\n            \"ae\",\n            \"a\",\n            \"1abde\",\n            \"lgpt\",\n            \"123456789\",\n            \"234678\",\n            \"codecomplete\",\n        ]\n        expected = [\"1abde\", \"abde\", \"ade\", \"ae\", \"a\"]\n        self.assertEqual(program.longestStringChain(strings), expected)\n",
      "SandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        strings = [\"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\"]\n        expected = [\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\"]\n        self.assertEqual(program.longestStringChain(strings), expected)\n",
      "Solutions": [
        "# Copyright © 2020 Code Complete. All rights reserved.\n\n# O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings and\n# m is the length of the longest string\ndef longestStringChain(strings):\n    # For every string, imagine the longest string chain that starts with it.\n    # Set up every string to point to the next string in its respective longest\n    # string chain. Also keep track of the lengths of these longest string chains.\n    stringChains = {}\n    for string in strings:\n        stringChains[string] = {\"nextString\": \"\", \"maxChainLength\": 1}\n\n    # Sort the strings based on their length so that whenever we visit a\n    # string (as we iterate through them from left to right), we can\n    # already have computed the longest string chains of any smaller strings.\n    sortedStrings = sorted(strings, key=len)\n    for string in sortedStrings:\n        findLongestStringChain(string, stringChains)\n\n    return buildLongestStringChain(strings, stringChains)\n\n\ndef findLongestStringChain(string, stringChains):\n    # Try removing every letter of the current string to see if the\n    # remaining strings form a string chain.\n    for i in range(len(string)):\n        smallerString = getSmallerString(string, i)\n        if smallerString not in stringChains:\n            continue\n        tryUpdateLongestStringChain(string, smallerString, stringChains)\n\n\ndef getSmallerString(string, index):\n    return string[0:index] + string[index + 1 :]\n\n\ndef tryUpdateLongestStringChain(currentString, smallerString, stringChains):\n    smallerStringChainLength = stringChains[smallerString][\"maxChainLength\"]\n    currentStringChainLength = stringChains[currentString][\"maxChainLength\"]\n    # Update the string chain of the current string only if the smaller string leads\n    # to a longer string chain.\n    if smallerStringChainLength + 1 > currentStringChainLength:\n        stringChains[currentString][\"maxChainLength\"] = smallerStringChainLength + 1\n        stringChains[currentString][\"nextString\"] = smallerString\n\n\ndef buildLongestStringChain(strings, stringChains):\n    # Find the string that starts the longest string chain.\n    maxChainLength = 0\n    chainStartingString = \"\"\n    for string in strings:\n        if stringChains[string][\"maxChainLength\"] > maxChainLength:\n            maxChainLength = stringChains[string][\"maxChainLength\"]\n            chainStartingString = string\n\n    # Starting at the string found above, build the longest string chain.\n    ourLongestStringChain = []\n    currentString = chainStartingString\n    while currentString != \"\":\n        ourLongestStringChain.append(currentString)\n        currentString = stringChains[currentString][\"nextString\"]\n\n    return [] if len(ourLongestStringChain) == 1 else ourLongestStringChain\n"
      ]
    },
    "swift": {
      "Language": "swift",
      "StartingCode": "class Program {\n  func longestStringChain(_ strings: [String]) -> [String] {\n    // Write your code here.\n    return []\n  }\n}\n",
      "StartingTest": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let input = [\"abcdefg\", \"abcdef\", \"abcde\", \"abcd\", \"abc\", \"ab\", \"a\"]\n      let expected = [\"abcdefg\", \"abcdef\", \"abcde\", \"abcd\", \"abc\", \"ab\", \"a\"]\n      let output = program.longestStringChain(input)\n      try assertEqual(output, expected)\n    }\n    runTest(\"Test Case 2\") { () throws -> Void in\n      let input = [\"abcdefg\", \"abdefg\", \"abdfg\", \"bdfg\", \"bfg\", \"bg\", \"g\"]\n      let expected = [\"abcdefg\", \"abdefg\", \"abdfg\", \"bdfg\", \"bfg\", \"bg\", \"g\"]\n      let output = program.longestStringChain(input)\n      try assertEqual(output, expected)\n    }\n    runTest(\"Test Case 3\") { () throws -> Void in\n      let input = [\n        \"abcdefg\",\n        \"1234\",\n        \"abdefg\",\n        \"abdfg\",\n        \"123\",\n        \"12\",\n        \"bg\",\n        \"g\",\n        \"12345\",\n        \"12a345\",\n      ]\n      let expected = [\"12a345\", \"12345\", \"1234\", \"123\", \"12\"]\n      let output = program.longestStringChain(input)\n      try assertEqual(output, expected)\n    }\n    runTest(\"Test Case 4\") { () throws -> Void in\n      let input = [\n        \"abcdefg1\",\n        \"1234c\",\n        \"abdefg2\",\n        \"abdfg\",\n        \"123\",\n        \"122\",\n        \"bgg\",\n        \"g\",\n        \"1a2345\",\n        \"12a345\",\n      ]\n      let expected = [String]()\n      let output = program.longestStringChain(input)\n      try assertEqual(output, expected)\n    }\n\n    runTest(\"Test Case 5\") { () throws -> Void in\n      let input = [\"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\"]\n      let expected = [\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\"]\n      let output = program.longestStringChain(input)\n      try assertEqual(output, expected)\n    }\n\n    runTest(\"Test Case 6\") { () throws -> Void in\n      let input = [\n        \"lgoprt\",\n        \"12345678\",\n        \"algoxpert\",\n        \"abcde\",\n        \"123468\",\n        \"lgoxprt\",\n        \"abde\",\n        \"lgopt\",\n        \"1234678\",\n        \"ade\",\n        \"ae\",\n        \"algoxprt\",\n        \"a\",\n        \"1abde\",\n        \"lgpt\",\n        \"123456789\",\n        \"234678\",\n        \"codecomplete\",\n      ]\n      let expected = [\n        \"codecomplete\",\n        \"algoxpert\",\n        \"algoxprt\",\n        \"lgoxprt\",\n        \"lgoprt\",\n        \"lgopt\",\n        \"lgpt\",\n      ]\n      let output = program.longestStringChain(input)\n      try assertEqual(output, expected)\n    }\n\n    runTest(\"Test Case 7\") { () throws -> Void in\n      let input = [\n        \"12345678\",\n        \"algoxpert\",\n        \"123468\",\n        \"abde\",\n        \"lgopt\",\n        \"1234678\",\n        \"ade\",\n        \"ae\",\n        \"a\",\n        \"1abde\",\n        \"lgpt\",\n        \"123456789\",\n        \"234678\",\n        \"codecomplete\",\n      ]\n      let expected = [\"1abde\", \"abde\", \"ade\", \"ae\", \"a\"]\n      let output = program.longestStringChain(input)\n      try assertEqual(output, expected)\n    }\n  }\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let input = [\"abde\", \"abc\", \"abd\", \"abcde\", \"ade\", \"ae\", \"1abde\", \"abcdef\"]\n      let expected = [\"abcdef\", \"abcde\", \"abde\", \"ade\", \"ae\"]\n      let output = program.longestStringChain(input)\n      try assertEqual(output, expected)\n    }\n  }\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nclass Program {\n  class Chain {\n    var nextString: String\n    var maxChainLength: Int\n\n    init(_ nextString: String, _ maxChainLength: Int) {\n      self.nextString = nextString\n      self.maxChainLength = maxChainLength\n    }\n  }\n\n  // O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings and\n  // m is the length of the longest string\n  func longestStringChain(_ strings: [String]) -> [String] {\n    // For every string, imagine the longest string chain that starts with it.\n    // Set up every string to point to the next string in its respective longest\n    // string chain. Also keep track of the lengths of these longest string chains.\n    var stringChains = [String: Chain]()\n    for str in strings {\n      stringChains[str] = Chain(\"\", 1)\n    }\n\n    // Sort the strings based on their length so that whenever we visit a\n    // string (as we iterate through them from left to right), we can\n    // already have computed the longest string chains of any smaller strings.\n    let sortedStrings = strings.sorted {\n      $0.length < $1.length\n    }\n\n    for str in sortedStrings {\n      findLongestStringChain(str, &stringChains)\n    }\n    return buildLongestStringChain(strings, &stringChains)\n  }\n\n  func findLongestStringChain(_ string: String, _ stringChains: inout [String: Chain]) {\n    // Try removing every letter of the current string to see if the\n    // remaining strings form a string chain.\n    for i in 0 ..< string.length {\n      let smallerString = getSmallerString(string, i)\n      if let _ = stringChains[smallerString] {\n        tryUpdateLongestStringChain(string, smallerString, &stringChains)\n      }\n    }\n  }\n\n  func getSmallerString(_ string: String, _ index: Int) -> String {\n    var s = string\n    let i = s.index(s.startIndex, offsetBy: index)\n    s.remove(at: i)\n    return s\n  }\n\n  func tryUpdateLongestStringChain(_ currentString: String, _ smallerString: String, _ stringChains: inout [String: Chain]) {\n    let smallerStringChainLength = stringChains[smallerString]!.maxChainLength\n    let currentStringChainLength = stringChains[currentString]!.maxChainLength\n    // Update the string chain of the current string only if the smaller string leads\n    // to a longer string chain.\n    if smallerStringChainLength + 1 > currentStringChainLength {\n      stringChains[currentString]!.maxChainLength = smallerStringChainLength + 1\n      stringChains[currentString]!.nextString = smallerString\n    }\n  }\n\n  func buildLongestStringChain(_ strings: [String], _ stringChains: inout [String: Chain]) -> [String] {\n    // Find the string that starts the longest string chain.\n    var maxChainLength = 0\n    var chainStartingString = \"\"\n    for str in strings {\n      if stringChains[str]!.maxChainLength > maxChainLength {\n        maxChainLength = stringChains[str]!.maxChainLength\n        chainStartingString = str\n      }\n    }\n\n    // Starting at the string found above, build the longest string chain.\n    var ourLongestStringChain = [String]()\n    var currentString = chainStartingString\n    while currentString != \"\" {\n      ourLongestStringChain.append(currentString)\n      currentString = stringChains[currentString]!.nextString\n    }\n\n    if ourLongestStringChain.count == 1 {\n      return [String]()\n    }\n    return ourLongestStringChain\n  }\n}\n"
      ]
    },
    "typescript": {
      "Language": "typescript",
      "StartingCode": "function longestStringChain(strings: string[]) {\n  // Write your code here.\n  return [''];\n}\n",
      "StartingTest": "",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const strings = ['abde', 'abc', 'abd', 'abcde', 'ade', 'ae', '1abde', 'abcdef'];\n  const expected = ['abcdef', 'abcde', 'abde', 'ade', 'ae'];\n  chai.expect(program.longestStringChain(strings)).to.deep.equal(expected);\n});\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\ninterface StringChains {\n  [key: string]: {\n    nextString: string;\n    maxChainLength: number;\n  };\n}\n\n// O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings and\n// m is the length of the longest string\nexport function longestStringChain(strings: string[]) {\n  // For every string, imagine the longest string chain that starts with it.\n  // Set up every string to point to the next string in its respective longest\n  // string chain. Also keep track of the lengths of these longest string chains.\n  const stringChains: StringChains = {};\n  for (const string of strings) {\n    stringChains[string] = {nextString: '', maxChainLength: 1};\n  }\n\n  // Sort the strings based on their length so that whenever we visit a\n  // string (as we iterate through them from left to right), we can\n  // already have computed the longest string chains of any smaller strings.\n  const sortedStrings = strings.sort((a, b) => a.length - b.length);\n  for (const string of sortedStrings) {\n    findLongestStringChain(string, stringChains);\n  }\n\n  return buildLongestStringChain(strings, stringChains);\n}\n\nfunction findLongestStringChain(string: string, stringChains: StringChains) {\n  // Try removing every letter of the current string to see if the\n  // remaining strings form a string chain.\n  for (let i = 0; i < string.length; i++) {\n    const smallerString = getSmallerString(string, i);\n    if (!(smallerString in stringChains)) continue;\n    tryUpdateLongestStringChain(string, smallerString, stringChains);\n  }\n}\n\nfunction getSmallerString(string: string, index: number) {\n  return string.slice(0, index) + string.slice(index + 1);\n}\n\nfunction tryUpdateLongestStringChain(currentString: string, smallerString: string, stringChains: StringChains) {\n  const smallerStringChainLength = stringChains[smallerString].maxChainLength;\n  const currentStringChainLength = stringChains[currentString].maxChainLength;\n  // Update the string chain of the current string only if the smaller string leads\n  // to a longer string chain.\n  if (smallerStringChainLength + 1 > currentStringChainLength) {\n    stringChains[currentString].maxChainLength = smallerStringChainLength + 1;\n    stringChains[currentString].nextString = smallerString;\n  }\n}\n\nfunction buildLongestStringChain(strings: string[], stringChains: StringChains) {\n  // Find the string that starts the longest string chain.\n  let maxChainLength = 0;\n  let chainStartingString = '';\n  for (const string of strings) {\n    if (stringChains[string].maxChainLength > maxChainLength) {\n      maxChainLength = stringChains[string].maxChainLength;\n      chainStartingString = string;\n    }\n  }\n\n  // Starting at the string found above, build the longest string chain.\n  const ourLongestStringChain: string[] = [];\n  let currentString = chainStartingString;\n  while (currentString !== '') {\n    ourLongestStringChain.push(currentString);\n    currentString = stringChains[currentString].nextString;\n  }\n\n  return ourLongestStringChain.length === 1 ? [] : ourLongestStringChain;\n}\n"
      ]
    }
  },
  "JSONTestLanguages": [
    "javascript",
    "cpp",
    "python",
    "java",
    "csharp",
    "go",
    "swift",
    "typescript"
  ],
  "JSONTests": [
    {
      "strings": [
        "abde",
        "abc",
        "abd",
        "abcde",
        "ade",
        "ae",
        "1abde",
        "abcdef"
      ]
    },
    {
      "strings": [
        "abcdefg",
        "abcdef",
        "abcde",
        "abcd",
        "abc",
        "ab",
        "a"
      ]
    },
    {
      "strings": [
        "abcdefg",
        "abdefg",
        "abdfg",
        "bdfg",
        "bfg",
        "bg",
        "g"
      ]
    },
    {
      "strings": [
        "abcdefg",
        "1234",
        "abdefg",
        "abdfg",
        "123",
        "12",
        "bg",
        "g",
        "12345",
        "12a345"
      ]
    },
    {
      "strings": [
        "abcdefg1",
        "1234c",
        "abdefg2",
        "abdfg",
        "123",
        "122",
        "bgg",
        "g",
        "1a2345",
        "12a345"
      ]
    },
    {
      "strings": [
        "odemplte",
        "12345678",
        "codecompete",
        "abcde",
        "123468",
        "odecomplet",
        "abde",
        "compl",
        "1234678",
        "ade",
        "ae",
        "codecolete",
        "a",
        "1abde",
        "lete",
        "123456789",
        "234678",
        "codecomplete"
      ]
    },
    {
      "strings": [
        "12345678",
        "algoxpert",
        "123468",
        "abde",
        "lgopt",
        "1234678",
        "ade",
        "ae",
        "a",
        "1abde",
        "lgpt",
        "123456789",
        "234678",
        "codecomplete"
      ]
    }
  ],
  "JSONAnswers": [
    [
      [
        "abcdef",
        "abcde",
        "abde",
        "ade",
        "ae"
      ],
      [
        "abcdefg",
        "abcdef",
        "abcde",
        "abcd",
        "abc",
        "ab",
        "a"
      ],
      [
        "abcdefg",
        "abdefg",
        "abdfg",
        "bdfg",
        "bfg",
        "bg",
        "g"
      ],
      [
        "12a345",
        "12345",
        "1234",
        "123",
        "12"
      ],
      [],
      [
       "abcde", "abde", "ade", "ae", "a"
      ],
      [
        "1abde",
        "abde",
        "ade",
        "ae",
        "a"
      ]
    ]
  ]
}
