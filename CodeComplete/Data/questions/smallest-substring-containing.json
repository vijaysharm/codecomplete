{
  "Summary": {
    "Name": "Smallest Substring Containing",
    "Category": "Strings",
    "Difficulty": 4,
    "Available": true,
    "Metadata": {
      "date": "2019-11-21T00:00:00Z",
      "number": 8,
      "timeOne": 0,
      "timeTwo": 1549,
      "url": "https://player.vimeo.com/video/374398372"
    }
  },
  "Prompt": "",
  "Hints": "Try storing all of the small string's character counts in a hash table where each character maps to the number of times that it appears in the small string.\nTry using two pointers (a left pointer and a right pointer) to traverse through the big string. How can this help you find the relevant smallest substring?\nWith the two pointers mentioned in Hint #2, move the right pointer to the right in the big string, keeping track of all the characters you visit in a hash table identical to the one mentioned in Hint #1, until you've found all of the characters contained in the small string. At that point, move the left pointer to the right in the big string, keeping track of all the characters you \"lose\", and stop once you no longer have all of the small string's characters in between the left and right pointers. Then, repeat the process by moving the right pointer forward and implementing the same logic described in this Hint.",
  "SpaceTime": "O(b + s) time | O(b + s) space - where b is the length of the big input string and s is the length of the small input string",
  "PromptHTML": "<p>\n  You're given two non-empty strings: a big string and a small string. Write a\n  function that returns the smallest substring in the big string that contains\n  all of the small string's characters.\n</p>\n<p>\n  Note that:\n</p>\n<ul>\n  <li>\n    - The substring can contain other characters not found in the small string.\n  </li>\n  <li>\n    - The characters in the substring don't have to be in the same order as they\n    appear in the small string.\n  </li>\n  <li>\n    - If the small string has duplicate characters, the substring has to contain\n    those duplicate characters (it can also contain more, but not fewer).\n  </li>\n</ul>\n<p>\n  You can assume that there will only be one relevant smallest substring.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">bigString</span> = \"abcd$ef$axb$c$\"\n<span class=\"CodeEditor-promptParameter\">smallString</span> = \"$$abf\"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n\"f$axb$\"\n</pre>\n",
  "Notes": "",
  "IsLongOutput": false,
  "Visualization": {
    "inputType": null,
    "outputType": null
  },
  "CustomInputLanguages": [
    "javascript",
    "cpp",
    "python",
    "java",
    "csharp",
    "go",
    "swift",
    "typescript"
  ],
  "CustomInputVars": [
    {
      "Name": "bigString",
      "Example": "abcd$ef$axb$c$",
      "Schema": {
        "minLength": 1,
        "type": "string"
      }
    },
    {
      "Name": "smallString",
      "Example": "$$abf",
      "Schema": {
        "minLength": 1,
        "type": "string"
      }
    }
  ],
  "Resources": {
    "cpp": {
      "Language": "cpp",
      "StartingCode": "using namespace std;\n\nstring smallestSubstringContaining(string bigString, string smallString) {\n  // Write your code here.\n  return \"\";\n}\n",
      "StartingTest": "class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n\n    RunTest(\"Test Case 1\", []() {\n      string bigString = \"abcdef\";\n      string smallString = \"fa\";\n      string expected = \"abcdef\";\n      assert(smallestSubstringContaining(bigString, smallString) == expected);\n    });\n\n    RunTest(\"Test Case 2\", []() {\n      string bigString = \"abcdef\";\n      string smallString = \"d\";\n      string expected = \"d\";\n      assert(smallestSubstringContaining(bigString, smallString) == expected);\n    });\n\n    RunTest(\"Test Case 3\", []() {\n      string bigString = \"abcdefghijklmnopqrstuvwxyz\";\n      string smallString = \"aajjttwwxxzz\";\n      string expected = \"\";\n      assert(smallestSubstringContaining(bigString, smallString) == expected);\n    });\n\n    RunTest(\"Test Case 4\", []() {\n      string bigString = \"abzacdwejxjftghiwjtklmnopqrstuvwxyz\";\n      string smallString = \"aajjttwwxxzz\";\n      string expected = \"abzacdwejxjftghiwjtklmnopqrstuvwxyz\";\n      assert(smallestSubstringContaining(bigString, smallString) == expected);\n    });\n\n    RunTest(\"Test Case 5\", []() {\n      string bigString = \"a$fuu+afff+affaffa+a$Affab+a+a+$a$\";\n      string smallString = \"a+$aaAaaaa$++\";\n      string expected = \"affa+a$Affab+a+a+$a\";\n      assert(smallestSubstringContaining(bigString, smallString) == expected);\n    });\n\n    RunTest(\"Test Case 6\", []() {\n      string bigString = \"aaaa+a$+aaa++$+++++++aaa\";\n      string smallString = \"a+$aaAaaaa$++\";\n      string expected = \"\";\n      assert(smallestSubstringContaining(bigString, smallString) == expected);\n    });\n\n    RunTest(\"Test Case 7\", []() {\n      string bigString = \"a$fuu+afff+affaffa+a$Affab+a+a+$a$\";\n      string smallString = \"a+$aaAaaaa$++\";\n      string expected = \"affa+a$Affab+a+a+$a\";\n      assert(smallestSubstringContaining(bigString, smallString) == expected);\n    });\n\n    RunTest(\"Test Case 8\", []() {\n      string bigString =\n          \"a$fuu+afff+affaffa+a$Affab+a+a+$a$bccgtt+aaaacA+++aaa$\";\n      string smallString = \"a+$aaAaaaa$++\";\n      string expected = \"affa+a$Affab+a+a+$a\";\n      assert(smallestSubstringContaining(bigString, smallString) == expected);\n    });\n\n    RunTest(\"Test Case 9\", []() {\n      string bigString = \"145624356128828193236336541277356789901\";\n      string smallString = \"123\";\n      string expected = \"1932\";\n      assert(smallestSubstringContaining(bigString, smallString) == expected);\n    });\n\n    RunTest(\"Test Case 10\", []() {\n      string bigString = \"1456243561288281932363365412356789901!\";\n      string smallString = \"123!\";\n      string expected = \"2356789901!\";\n      assert(smallestSubstringContaining(bigString, smallString) == expected);\n    });\n\n    RunTest(\"Test Case 11\", []() {\n      string bigString = \"14562435612!88281932363365$412356789901\";\n      string smallString = \"$123!\";\n      string expected = \"!88281932363365$\";\n      assert(smallestSubstringContaining(bigString, smallString) == expected);\n    });\n\n    RunTest(\"Test Case 12\", []() {\n      string bigString = \"14562435612!88281932363365$412356789901\";\n      string smallString = \"#!123!\";\n      string expected = \"\";\n      assert(smallestSubstringContaining(bigString, smallString) == expected);\n    });\n\n    RunTest(\"Test Case 13\", []() {\n      string bigString = \"14562435612!88281932363365$412356789901\";\n      string smallString = \"#!333333123!\";\n      string expected = \"\";\n      ;\n      assert(smallestSubstringContaining(bigString, smallString) == expected);\n    });\n\n    RunTest(\"Test Case 14\", []() {\n      string bigString = \"14562435612z!8828!193236!336!5$41!23!5!6789901#\";\n      string smallString = \"#!2z\";\n      string expected = \"z!8828!193236!336!5$41!23!5!6789901#\";\n      assert(smallestSubstringContaining(bigString, smallString) == expected);\n    });\n\n    RunTest(\"Test Case 15\", []() {\n      string bigString = \"14562435612z!8828!193236!336!5$41!23!5!6789901#z2!\";\n      string smallString = \"#!2z\";\n      string expected = \"#z2!\";\n      assert(smallestSubstringContaining(bigString, smallString) == expected);\n    });\n\n    RunTest(\"Test Case 16\", []() {\n      string bigString = \"abcd$ef$axb$c$\";\n      string smallString = \"$$abf\";\n      string expected = \"f$axb$\";\n      assert(smallestSubstringContaining(bigString, smallString) == expected);\n    });\n  }\n};\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      string bigString = \"abcd$ef$axb$c$\";\n      string smallString = \"$$abf\";\n      string expected = \"f$axb$\";\n      assert(smallestSubstringContaining(bigString, smallString) == expected);\n    });\n  }\n};\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\n#include <climits>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nstring smallestSubstringContaining(string bigString, string smallString);\nunordered_map<char, int> getCharCounts(string str);\nvector<int> getSubstringBounds(string str,\n                               unordered_map<char, int> targetCharCounts);\nvector<int> getCloserBounds(int idx1, int idx2, int idx3, int idx4);\nstring getStringFromBounds(string str, vector<int> bounds);\nvoid increaseCharCount(char c, unordered_map<char, int> &charCounts);\nvoid decreaseCharCount(char c, unordered_map<char, int> &charCounts);\n\n// O(b + s) time | O(b + s) space - where b is the length of the big\n// input string and s is the length of the small input string\nstring smallestSubstringContaining(string bigString, string smallString) {\n  unordered_map<char, int> targetCharCounts = getCharCounts(smallString);\n  vector<int> substringBounds = getSubstringBounds(bigString, targetCharCounts);\n  return getStringFromBounds(bigString, substringBounds);\n}\n\nunordered_map<char, int> getCharCounts(string str) {\n  unordered_map<char, int> charCounts;\n  for (auto c : str) {\n    increaseCharCount(c, charCounts);\n  }\n  return charCounts;\n}\n\nvector<int> getSubstringBounds(string str,\n                               unordered_map<char, int> targetCharCounts) {\n  vector<int> substringBounds = {0, INT_MAX};\n  unordered_map<char, int> substringCharCounts;\n  int numUniqueChars = targetCharCounts.size();\n  int numUniqueCharsDone = 0;\n  int leftIdx = 0;\n  int rightIdx = 0;\n  // Move the rightIdx to the right in the string until you've counted\n  // all of the target characters enough times.\n  while (rightIdx < str.size()) {\n    char rightChar = str[rightIdx];\n    if (targetCharCounts.find(rightChar) == targetCharCounts.end()) {\n      rightIdx++;\n      continue;\n    }\n    increaseCharCount(rightChar, substringCharCounts);\n    if (substringCharCounts[rightChar] == targetCharCounts[rightChar]) {\n      numUniqueCharsDone++;\n    }\n    // Move the leftIdx to the right in the string until you no longer\n    // have enough of the target characters in between the leftIdx and\n    // the rightIdx. Update the substringBounds accordingly.\n    while (numUniqueCharsDone == numUniqueChars && leftIdx <= rightIdx) {\n      substringBounds = getCloserBounds(leftIdx, rightIdx, substringBounds[0],\n                                        substringBounds[1]);\n      char leftChar = str[leftIdx];\n      if (targetCharCounts.find(leftChar) == targetCharCounts.end()) {\n        leftIdx++;\n        continue;\n      }\n      if (substringCharCounts[leftChar] == targetCharCounts[leftChar]) {\n        numUniqueCharsDone--;\n      }\n      decreaseCharCount(leftChar, substringCharCounts);\n      leftIdx++;\n    }\n    rightIdx++;\n  }\n  return substringBounds;\n}\n\nvector<int> getCloserBounds(int idx1, int idx2, int idx3, int idx4) {\n  return idx2 - idx1 < idx4 - idx3 ? vector<int>{idx1, idx2}\n                                   : vector<int>{idx3, idx4};\n}\n\nstring getStringFromBounds(string str, vector<int> bounds) {\n  int start = bounds[0];\n  int end = bounds[1];\n  if (end == INT_MAX)\n    return \"\";\n  return str.substr(start, end - start + 1);\n}\n\nvoid increaseCharCount(char c, unordered_map<char, int> &charCounts) {\n  if (charCounts.find(c) == charCounts.end()) {\n    charCounts[c] = 1;\n  } else {\n    charCounts[c]++;\n  }\n}\n\nvoid decreaseCharCount(char c, unordered_map<char, int> &charCounts) {\n  charCounts[c]--;\n}\n"
      ]
    },
    "csharp": {
      "Language": "csharp",
      "StartingCode": "\npublic class Program {\n\tpublic static string SmallestSubstringContaining(string bigstring, string smallstring) {\n\t\t// Write your code here.\n\t\treturn null;\n\t}\n}\n",
      "StartingTest": "public class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tstring bigstring = \"abcdef\";\n\t\tstring smallstring = \"fa\";\n\t\tstring expected = \"abcdef\";\n\t\tUtils.AssertTrue(Program.SmallestSubstringContaining(bigstring,\n\t\t  smallstring).Equals(expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase2() {\n\t\tstring bigstring = \"abcdef\";\n\t\tstring smallstring = \"d\";\n\t\tstring expected = \"d\";\n\t\tUtils.AssertTrue(Program.SmallestSubstringContaining(bigstring,\n\t\t  smallstring).Equals(expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase3() {\n\t\tstring bigstring = \"abcdefghijklmnopqrstuvwxyz\";\n\t\tstring smallstring = \"aajjttwwxxzz\";\n\t\tstring expected = \"\";\n\t\tUtils.AssertTrue(Program.SmallestSubstringContaining(bigstring,\n\t\t  smallstring).Equals(expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase4() {\n\t\tstring bigstring = \"abzacdwejxjftghiwjtklmnopqrstuvwxyz\";\n\t\tstring smallstring = \"aajjttwwxxzz\";\n\t\tstring expected = \"abzacdwejxjftghiwjtklmnopqrstuvwxyz\";\n\t\tUtils.AssertTrue(Program.SmallestSubstringContaining(bigstring,\n\t\t  smallstring).Equals(expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase5() {\n\t\tstring bigstring = \"a$fuu+afff+affaffa+a$Affab+a+a+$a$\";\n\t\tstring smallstring = \"a+$aaAaaaa$++\";\n\t\tstring expected = \"affa+a$Affab+a+a+$a\";\n\t\tUtils.AssertTrue(Program.SmallestSubstringContaining(bigstring,\n\t\t  smallstring).Equals(expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase6() {\n\t\tstring bigstring = \"aaaa+a$+aaa++$+++++++aaa\";\n\t\tstring smallstring = \"a+$aaAaaaa$++\";\n\t\tstring expected = \"\";\n\t\tUtils.AssertTrue(Program.SmallestSubstringContaining(bigstring,\n\t\t  smallstring).Equals(expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase7() {\n\t\tstring bigstring = \"a$fuu+afff+affaffa+a$Affab+a+a+$a$\";\n\t\tstring smallstring = \"a+$aaAaaaa$++\";\n\t\tstring expected = \"affa+a$Affab+a+a+$a\";\n\t\tUtils.AssertTrue(Program.SmallestSubstringContaining(bigstring,\n\t\t  smallstring).Equals(expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase8() {\n\t\tstring bigstring = \"a$fuu+afff+affaffa+a$Affab+a+a+$a$bccgtt+aaaacA+++aaa$\";\n\t\tstring smallstring = \"a+$aaAaaaa$++\";\n\t\tstring expected = \"affa+a$Affab+a+a+$a\";\n\t\tUtils.AssertTrue(Program.SmallestSubstringContaining(bigstring,\n\t\t  smallstring).Equals(expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase9() {\n\t\tstring bigstring = \"145624356128828193236336541277356789901\";\n\t\tstring smallstring = \"123\";\n\t\tstring expected = \"1932\";\n\t\tUtils.AssertTrue(Program.SmallestSubstringContaining(bigstring,\n\t\t  smallstring).Equals(expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase10() {\n\t\tstring bigstring = \"1456243561288281932363365412356789901!\";\n\t\tstring smallstring = \"123!\";\n\t\tstring expected = \"2356789901!\";\n\t\tUtils.AssertTrue(Program.SmallestSubstringContaining(bigstring,\n\t\t  smallstring).Equals(expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase11() {\n\t\tstring bigstring = \"14562435612!88281932363365$412356789901\";\n\t\tstring smallstring = \"$123!\";\n\t\tstring expected = \"!88281932363365$\";\n\t\tUtils.AssertTrue(Program.SmallestSubstringContaining(bigstring,\n\t\t  smallstring).Equals(expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase12() {\n\t\tstring bigstring = \"14562435612!88281932363365$412356789901\";\n\t\tstring smallstring = \"#!123!\";\n\t\tstring expected = \"\";\n\t\tUtils.AssertTrue(Program.SmallestSubstringContaining(bigstring,\n\t\t  smallstring).Equals(expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase13() {\n\t\tstring bigstring = \"14562435612!88281932363365$412356789901\";\n\t\tstring smallstring = \"#!333333123!\";\n\t\tstring expected = \"\";\n\t\tUtils.AssertTrue(Program.SmallestSubstringContaining(bigstring,\n\t\t  smallstring).Equals(expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase14() {\n\t\tstring bigstring = \"14562435612z!8828!193236!336!5$41!23!5!6789901#\";\n\t\tstring smallstring = \"#!2z\";\n\t\tstring expected = \"z!8828!193236!336!5$41!23!5!6789901#\";\n\t\tUtils.AssertTrue(Program.SmallestSubstringContaining(bigstring,\n\t\t  smallstring).Equals(expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase15() {\n\t\tstring bigstring = \"14562435612z!8828!193236!336!5$41!23!5!6789901#z2!\";\n\t\tstring smallstring = \"#!2z\";\n\t\tstring expected = \"#z2!\";\n\t\tUtils.AssertTrue(Program.SmallestSubstringContaining(bigstring,\n\t\t  smallstring).Equals(expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase16() {\n\t\tstring bigstring = \"abcd$ef$axb$c$\";\n\t\tstring smallstring = \"$$abf\";\n\t\tstring expected = \"f$axb$\";\n\t\tUtils.AssertTrue(Program.SmallestSubstringContaining(bigstring,\n\t\t  smallstring).Equals(expected));\n\t}\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tstring bigstring = \"abcd$ef$axb$c$\";\n\t\tstring smallstring = \"$$abf\";\n\t\tstring expected = \"f$axb$\";\n\t\tUtils.AssertTrue(Program.SmallestSubstringContaining(bigstring,\n\t\t  smallstring).Equals(expected));\n\t}\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nusing System;\nusing System.Collections.Generic;\n\npublic class Program {\n\t// O(b + s) time | O(b + s) space - where b is the length of the big\n\t// input string and s is the length of the small input string\n\tpublic static string SmallestSubstringContaining(string bigstring, string smallstring) {\n\t\tDictionary<char, int> targetCharCounts = getCharCounts(smallstring);\n\t\tList<int> substringBounds = getSubstringBounds(bigstring, targetCharCounts);\n\t\treturn getstringFromBounds(bigstring, substringBounds);\n\t}\n\n\tpublic static Dictionary<char, int> getCharCounts(string str) {\n\t\tDictionary<char, int> charCounts = new Dictionary<char, int>();\n\t\tfor (int i = 0; i < str.Length; i++ ) {\n\t\t\tincreaseCharCount(str[i], charCounts);\n\t\t}\n\t\treturn charCounts;\n\t}\n\n\tpublic static List<int> getSubstringBounds(string str, Dictionary<char,\n\t  int> targetCharCounts) {\n\t\tList<int> substringBounds = new List<int>(){\n\t\t\t0, Int32.MaxValue\n\t\t};\n\t\tDictionary<char, int> substringCharCounts = new Dictionary<char, int>();\n\t\tint numUniqueChars = targetCharCounts.Count;\n\t\tint numUniqueCharsDone = 0;\n\t\tint leftIdx = 0;\n\t\tint rightIdx = 0;\n\t\t// Move the rightIdx to the right in the string until you've counted\n\t\t// all of the target characters enough times.\n\t\twhile (rightIdx < str.Length) {\n\t\t\tchar rightChar = str[rightIdx];\n\t\t\tif (!targetCharCounts.ContainsKey(rightChar)) {\n\t\t\t\trightIdx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tincreaseCharCount(rightChar, substringCharCounts);\n\t\t\tif (substringCharCounts[rightChar] == targetCharCounts[rightChar]) {\n\t\t\t\tnumUniqueCharsDone++;\n\t\t\t}\n\t\t\t// Move the leftIdx to the right in the string until you no longer\n\t\t\t// have enough of the target characters in between the leftIdx and\n\t\t\t// the rightIdx. Update the substringBounds accordingly.\n\t\t\twhile (numUniqueCharsDone == numUniqueChars && leftIdx <= rightIdx) {\n\t\t\t\tsubstringBounds = getCloserBounds(leftIdx, rightIdx,\n\t\t\t\t    substringBounds[0],\n\t\t\t\t    substringBounds[1]);\n\t\t\t\tchar leftChar = str[leftIdx];\n\t\t\t\tif (!targetCharCounts.ContainsKey(leftChar)) {\n\t\t\t\t\tleftIdx++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (substringCharCounts[leftChar] == targetCharCounts[leftChar]) {\n\t\t\t\t\tnumUniqueCharsDone--;\n\t\t\t\t}\n\t\t\t\tdecreaseCharCount(leftChar, substringCharCounts);\n\t\t\t\tleftIdx++;\n\t\t\t}\n\t\t\trightIdx++;\n\t\t}\n\t\treturn substringBounds;\n\t}\n\n\tpublic static List<int> getCloserBounds(int idx1, int idx2, int idx3, int idx4) {\n\t\treturn idx2 - idx1 < idx4 - idx3 ? new List<int>(){\n\t\t\t       idx1, idx2\n\t\t}\n\t\t       : new List<int>(){\n\t\t\t       idx3, idx4\n\t\t       };\n\t}\n\n\tpublic static string getstringFromBounds(string str, List<int> bounds) {\n\t\tint start = bounds[0];\n\t\tint end = bounds[1];\n\t\tif (end == Int32.MaxValue)\n\t\t\treturn \"\";\n\t\treturn str.Substring(start, end + 1 - start);\n\t}\n\n\tpublic static void increaseCharCount(char c, Dictionary<char, int> charCounts) {\n\t\tif (!charCounts.ContainsKey(c)) {\n\t\t\tcharCounts[c] = 1;\n\t\t} else {\n\t\t\tcharCounts[c] = charCounts[c] + 1;\n\t\t}\n\t}\n\n\tpublic static void decreaseCharCount(char c, Dictionary<char, int> charCounts) {\n\t\tcharCounts[c]  = charCounts[c] - 1;\n\t}\n}\n"
      ]
    },
    "go": {
      "Language": "go",
      "StartingCode": "package main\n\nfunc SmallestSubstringContaining(bigString, smallString string) string {\n\t// Write your code here.\n\treturn \"\"\n}\n",
      "StartingTest": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tbigString := \"abcdef\"\n\tsmallString := \"fa\"\n\texpected := \"abcdef\"\n\trequire.Equal(t,\n\t\tSmallestSubstringContaining(bigString, smallString), expected,\n\t)\n}\n\nfunc (s *TestSuite) TestCase2(t *TestCase) {\n\tbigString := \"abcdef\"\n\tsmallString := \"d\"\n\texpected := \"d\"\n\trequire.Equal(t,\n\t\tSmallestSubstringContaining(bigString, smallString), expected,\n\t)\n}\n\nfunc (s *TestSuite) TestCase3(t *TestCase) {\n\tbigString := \"abcdefghijklmnopqrstuvwxyz\"\n\tsmallString := \"aajjttwwxxzz\"\n\texpected := \"\"\n\trequire.Equal(t,\n\t\tSmallestSubstringContaining(bigString, smallString), expected,\n\t)\n}\n\nfunc (s *TestSuite) TestCase4(t *TestCase) {\n\tbigString := \"abzacdwejxjftghiwjtklmnopqrstuvwxyz\"\n\tsmallString := \"aajjttwwxxzz\"\n\texpected := \"abzacdwejxjftghiwjtklmnopqrstuvwxyz\"\n\trequire.Equal(t,\n\t\tSmallestSubstringContaining(bigString, smallString), expected,\n\t)\n}\n\nfunc (s *TestSuite) TestCase5(t *TestCase) {\n\tbigString := \"abzacdwejxjfxztghiwjtklmnopqrstuvwxyz\"\n\tsmallString := \"aajjttwwxxzz\"\n\texpected := \"abzacdwejxjfxztghiwjt\"\n\trequire.Equal(t,\n\t\tSmallestSubstringContaining(bigString, smallString), expected,\n\t)\n}\n\nfunc (s *TestSuite) TestCase6(t *TestCase) {\n\tbigString := \"aaaa+a$+aaa++$+++++++aaa\"\n\tsmallString := \"a+$aaAaaaa$++\"\n\texpected := \"\"\n\trequire.Equal(t,\n\t\tSmallestSubstringContaining(bigString, smallString), expected,\n\t)\n}\n\nfunc (s *TestSuite) TestCase7(t *TestCase) {\n\tbigString := \"a$fuu+afff+affaffa+a$Affab+a+a+$a$\"\n\tsmallString := \"a+$aaAaaaa$++\"\n\texpected := \"affa+a$Affab+a+a+$a\"\n\trequire.Equal(t,\n\t\tSmallestSubstringContaining(bigString, smallString), expected,\n\t)\n}\n\nfunc (s *TestSuite) TestCase8(t *TestCase) {\n\tbigString := \"a$fuu+afff+affaffa+a$Affab+a+a+$a$bccgtt+aaaacA+++aaa$\"\n\tsmallString := \"a+$aaAaaaa$++\"\n\texpected := \"affa+a$Affab+a+a+$a\"\n\trequire.Equal(t,\n\t\tSmallestSubstringContaining(bigString, smallString), expected,\n\t)\n}\n\nfunc (s *TestSuite) TestCase9(t *TestCase) {\n\tbigString := \"145624356128828193236336541277356789901\"\n\tsmallString := \"123\"\n\texpected := \"1932\"\n\trequire.Equal(t,\n\t\tSmallestSubstringContaining(bigString, smallString), expected,\n\t)\n}\n\nfunc (s *TestSuite) TestCase10(t *TestCase) {\n\tbigString := \"1456243561288281932363365412356789901!\"\n\tsmallString := \"123!\"\n\texpected := \"2356789901!\"\n\trequire.Equal(t,\n\t\tSmallestSubstringContaining(bigString, smallString), expected,\n\t)\n}\n\nfunc (s *TestSuite) TestCase11(t *TestCase) {\n\tbigString := \"14562435612!88281932363365$412356789901\"\n\tsmallString := \"$123!\"\n\texpected := \"!88281932363365$\"\n\trequire.Equal(t,\n\t\tSmallestSubstringContaining(bigString, smallString), expected,\n\t)\n}\n\nfunc (s *TestSuite) TestCase12(t *TestCase) {\n\tbigString := \"14562435612!88281932363365$412356789901\"\n\tsmallString := \"#!123!\"\n\texpected := \"\"\n\trequire.Equal(t,\n\t\tSmallestSubstringContaining(bigString, smallString), expected,\n\t)\n}\n\nfunc (s *TestSuite) TestCase13(t *TestCase) {\n\tbigString := \"14562435612!88281932363365$412356789901\"\n\tsmallString := \"#!333333123!\"\n\texpected := \"\"\n\trequire.Equal(t,\n\t\tSmallestSubstringContaining(bigString, smallString), expected,\n\t)\n}\n\nfunc (s *TestSuite) TestCase14(t *TestCase) {\n\tbigString := \"14562435612z!8828!193236!336!5$41!23!5!6789901#\"\n\tsmallString := \"#!2z\"\n\texpected := \"z!8828!193236!336!5$41!23!5!6789901#\"\n\trequire.Equal(t,\n\t\tSmallestSubstringContaining(bigString, smallString), expected,\n\t)\n}\n\nfunc (s *TestSuite) TestCase15(t *TestCase) {\n\tbigString := \"14562435612z!8828!193236!336!5$41!23!5!6789901#z2!\"\n\tsmallString := \"#!2z\"\n\texpected := \"#z2!\"\n\trequire.Equal(t,\n\t\tSmallestSubstringContaining(bigString, smallString), expected,\n\t)\n}\n\nfunc (s *TestSuite) TestCase16(t *TestCase) {\n\tbigString := \"abcd$ef$axb$c$\"\n\tsmallString := \"$$abf\"\n\texpected := \"f$axb$\"\n\trequire.Equal(t,\n\t\tSmallestSubstringContaining(bigString, smallString), expected,\n\t)\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tbigString := \"abcd$ef$axb$c$\"\n\tsmallString := \"$$abf\"\n\texpected := \"f$axb$\"\n\trequire.Equal(t,\n\t\tSmallestSubstringContaining(bigString, smallString), expected,\n\t)\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\npackage main\n\nimport \"math\"\n\n// O(b + s) time | O(b + s) space - where b is the length of the big\n// input string and s is the length of the small input string\nfunc SmallestSubstringContaining(bigString, smallString string) string {\n\ttargetCharCounts := getCharCounts(smallString)\n\tsubstringBounds := getSubstringBounds(bigString, targetCharCounts)\n\treturn getStringFromBounds(bigString, substringBounds)\n}\n\nfunc getCharCounts(str string) map[byte]int {\n\tcharCounts := map[byte]int{}\n\tfor _, char := range str {\n\t\tincreaseCharCount(byte(char), charCounts)\n\t}\n\treturn charCounts\n}\n\nfunc getSubstringBounds(str string, targetCharCounts map[byte]int) []int {\n\tsubstringBounds := []int{0, math.MaxInt32}\n\tsubstringCharCounts := map[byte]int{}\n\tnumUniqueChars := len(targetCharCounts)\n\tnumUniqueCharsDone := 0\n\tleftIdx := 0\n\trightIdx := 0\n\n\t// Move the rightIdx to the right in the string until you've counted\n\t// all of the target characters enough times.\n\tfor rightIdx < len(str) {\n\t\trightChar := str[rightIdx]\n\t\tif _, found := targetCharCounts[rightChar]; !found {\n\t\t\trightIdx++\n\t\t\tcontinue\n\t\t}\n\t\tincreaseCharCount(rightChar, substringCharCounts)\n\t\tif substringCharCounts[rightChar] == targetCharCounts[rightChar] {\n\t\t\tnumUniqueCharsDone++\n\t\t}\n\n\t\t// Move the leftIdx to the right in the string until you no longer\n\t\t// have enough of the target characters in between the leftIdx and\n\t\t// the rightIdx. Update the substringBounds accordingly.\n\t\tfor numUniqueCharsDone == numUniqueChars && leftIdx <= rightIdx {\n\t\t\tsubstringBounds = getCloserBounds(\n\t\t\t\tleftIdx, rightIdx, substringBounds[0], substringBounds[1],\n\t\t\t)\n\t\t\tleftChar := str[leftIdx]\n\t\t\tif _, found := targetCharCounts[leftChar]; !found {\n\t\t\t\tleftIdx++\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif substringCharCounts[leftChar] == targetCharCounts[leftChar] {\n\t\t\t\tnumUniqueCharsDone--\n\t\t\t}\n\t\t\tdecreaseCharCount(leftChar, substringCharCounts)\n\t\t\tleftIdx++\n\t\t}\n\t\trightIdx++\n\t}\n\treturn substringBounds\n}\n\nfunc getCloserBounds(idx1, idx2, idx3, idx4 int) []int {\n\tif idx2-idx1 < idx4-idx3 {\n\t\treturn []int{idx1, idx2}\n\t}\n\treturn []int{idx3, idx4}\n}\n\nfunc getStringFromBounds(str string, bounds []int) string {\n\tstart, end := bounds[0], bounds[1]\n\tif end == math.MaxInt32 {\n\t\treturn \"\"\n\t}\n\treturn str[start : end+1]\n}\n\nfunc increaseCharCount(char byte, charCounts map[byte]int) {\n\tcharCounts[char]++\n}\n\nfunc decreaseCharCount(char byte, charCounts map[byte]int) {\n\tcharCounts[char]--\n}\n"
      ]
    },
    "java": {
      "Language": "java",
      "StartingCode": "import java.util.*;\n\nclass Program {\n  public static String smallestSubstringContaining(String bigString, String smallString) {\n    // Write your code here.\n    return \"\";\n  }\n}\n",
      "StartingTest": "class ProgramTest {\n  @Test\n  public void TestCase1() {\n    String bigString = \"abcdef\";\n    String smallString = \"fa\";\n    String expected = \"abcdef\";\n    Utils.assertTrue(Program.smallestSubstringContaining(bigString, smallString).equals(expected));\n  }\n\n  @Test\n  public void TestCase2() {\n    String bigString = \"abcdef\";\n    String smallString = \"d\";\n    String expected = \"d\";\n    Utils.assertTrue(Program.smallestSubstringContaining(bigString, smallString).equals(expected));\n  }\n\n  @Test\n  public void TestCase3() {\n    String bigString = \"abcdefghijklmnopqrstuvwxyz\";\n    String smallString = \"aajjttwwxxzz\";\n    String expected = \"\";\n    Utils.assertTrue(Program.smallestSubstringContaining(bigString, smallString).equals(expected));\n  }\n\n  @Test\n  public void TestCase4() {\n    String bigString = \"abzacdwejxjftghiwjtklmnopqrstuvwxyz\";\n    String smallString = \"aajjttwwxxzz\";\n    String expected = \"abzacdwejxjftghiwjtklmnopqrstuvwxyz\";\n    Utils.assertTrue(Program.smallestSubstringContaining(bigString, smallString).equals(expected));\n  }\n\n  @Test\n  public void TestCase5() {\n    String bigString = \"a$fuu+afff+affaffa+a$Affab+a+a+$a$\";\n    String smallString = \"a+$aaAaaaa$++\";\n    String expected = \"affa+a$Affab+a+a+$a\";\n    Utils.assertTrue(Program.smallestSubstringContaining(bigString, smallString).equals(expected));\n  }\n\n  @Test\n  public void TestCase6() {\n    String bigString = \"aaaa+a$+aaa++$+++++++aaa\";\n    String smallString = \"a+$aaAaaaa$++\";\n    String expected = \"\";\n    Utils.assertTrue(Program.smallestSubstringContaining(bigString, smallString).equals(expected));\n  }\n\n  @Test\n  public void TestCase7() {\n    String bigString = \"a$fuu+afff+affaffa+a$Affab+a+a+$a$\";\n    String smallString = \"a+$aaAaaaa$++\";\n    String expected = \"affa+a$Affab+a+a+$a\";\n    Utils.assertTrue(Program.smallestSubstringContaining(bigString, smallString).equals(expected));\n  }\n\n  @Test\n  public void TestCase8() {\n    String bigString = \"a$fuu+afff+affaffa+a$Affab+a+a+$a$bccgtt+aaaacA+++aaa$\";\n    String smallString = \"a+$aaAaaaa$++\";\n    String expected = \"affa+a$Affab+a+a+$a\";\n    Utils.assertTrue(Program.smallestSubstringContaining(bigString, smallString).equals(expected));\n  }\n\n  @Test\n  public void TestCase9() {\n    String bigString = \"145624356128828193236336541277356789901\";\n    String smallString = \"123\";\n    String expected = \"1932\";\n    Utils.assertTrue(Program.smallestSubstringContaining(bigString, smallString).equals(expected));\n  }\n\n  @Test\n  public void TestCase10() {\n    String bigString = \"1456243561288281932363365412356789901!\";\n    String smallString = \"123!\";\n    String expected = \"2356789901!\";\n    Utils.assertTrue(Program.smallestSubstringContaining(bigString, smallString).equals(expected));\n  }\n\n  @Test\n  public void TestCase11() {\n    String bigString = \"14562435612!88281932363365$412356789901\";\n    String smallString = \"$123!\";\n    String expected = \"!88281932363365$\";\n    Utils.assertTrue(Program.smallestSubstringContaining(bigString, smallString).equals(expected));\n  }\n\n  @Test\n  public void TestCase12() {\n    String bigString = \"14562435612!88281932363365$412356789901\";\n    String smallString = \"#!123!\";\n    String expected = \"\";\n    Utils.assertTrue(Program.smallestSubstringContaining(bigString, smallString).equals(expected));\n  }\n\n  @Test\n  public void TestCase13() {\n    String bigString = \"14562435612!88281932363365$412356789901\";\n    String smallString = \"#!333333123!\";\n    String expected = \"\";\n    Utils.assertTrue(Program.smallestSubstringContaining(bigString, smallString).equals(expected));\n  }\n\n  @Test\n  public void TestCase14() {\n    String bigString = \"14562435612z!8828!193236!336!5$41!23!5!6789901#\";\n    String smallString = \"#!2z\";\n    String expected = \"z!8828!193236!336!5$41!23!5!6789901#\";\n    Utils.assertTrue(Program.smallestSubstringContaining(bigString, smallString).equals(expected));\n  }\n\n  @Test\n  public void TestCase15() {\n    String bigString = \"14562435612z!8828!193236!336!5$41!23!5!6789901#z2!\";\n    String smallString = \"#!2z\";\n    String expected = \"#z2!\";\n    Utils.assertTrue(Program.smallestSubstringContaining(bigString, smallString).equals(expected));\n  }\n\n  @Test\n  public void TestCase16() {\n    String bigString = \"abcd$ef$axb$c$\";\n    String smallString = \"$$abf\";\n    String expected = \"f$axb$\";\n    Utils.assertTrue(Program.smallestSubstringContaining(bigString, smallString).equals(expected));\n  }\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    String bigString = \"abcd$ef$axb$c$\";\n    String smallString = \"$$abf\";\n    String expected = \"f$axb$\";\n    Utils.assertTrue(Program.smallestSubstringContaining(bigString, smallString).equals(expected));\n  }\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(b + s) time | O(b + s) space - where b is the length of the big\n  // input string and s is the length of the small input string\n  public static String smallestSubstringContaining(String bigString, String smallString) {\n    Map<Character, Integer> targetCharCounts = getCharCounts(smallString);\n    List<Integer> substringBounds = getSubstringBounds(bigString, targetCharCounts);\n    return getStringFromBounds(bigString, substringBounds);\n  }\n\n  public static Map<Character, Integer> getCharCounts(String string) {\n    Map<Character, Integer> charCounts = new HashMap<Character, Integer>();\n    for (int i = 0; i < string.length(); i++) {\n      increaseCharCount(string.charAt(i), charCounts);\n    }\n    return charCounts;\n  }\n\n  public static List<Integer> getSubstringBounds(\n      String string, Map<Character, Integer> targetCharCounts) {\n    List<Integer> substringBounds = new ArrayList<Integer>(Arrays.asList(0, Integer.MAX_VALUE));\n    Map<Character, Integer> substringCharCounts = new HashMap<Character, Integer>();\n    int numUniqueChars = targetCharCounts.size();\n    int numUniqueCharsDone = 0;\n    int leftIdx = 0;\n    int rightIdx = 0;\n    // Move the rightIdx to the right in the string until you've counted\n    // all of the target characters enough times.\n    while (rightIdx < string.length()) {\n      char rightChar = string.charAt(rightIdx);\n      if (!targetCharCounts.containsKey(rightChar)) {\n        rightIdx++;\n        continue;\n      }\n      increaseCharCount(rightChar, substringCharCounts);\n      if (substringCharCounts.get(rightChar) == targetCharCounts.get(rightChar)) {\n        numUniqueCharsDone++;\n      }\n      // Move the leftIdx to the right in the string until you no longer\n      // have enough of the target characters in between the leftIdx and\n      // the rightIdx. Update the substringBounds accordingly.\n      while (numUniqueCharsDone == numUniqueChars && leftIdx <= rightIdx) {\n        substringBounds =\n            getCloserBounds(leftIdx, rightIdx, substringBounds.get(0), substringBounds.get(1));\n        char leftChar = string.charAt(leftIdx);\n        if (!targetCharCounts.containsKey(leftChar)) {\n          leftIdx++;\n          continue;\n        }\n        if (substringCharCounts.get(leftChar) == targetCharCounts.get(leftChar)) {\n          numUniqueCharsDone--;\n        }\n        decreaseCharCount(leftChar, substringCharCounts);\n        leftIdx++;\n      }\n      rightIdx++;\n    }\n    return substringBounds;\n  }\n\n  public static List<Integer> getCloserBounds(int idx1, int idx2, int idx3, int idx4) {\n    return idx2 - idx1 < idx4 - idx3\n        ? new ArrayList<Integer>(Arrays.asList(idx1, idx2))\n        : new ArrayList<Integer>(Arrays.asList(idx3, idx4));\n  }\n\n  public static String getStringFromBounds(String string, List<Integer> bounds) {\n    int start = bounds.get(0);\n    int end = bounds.get(1);\n    if (end == Integer.MAX_VALUE) return \"\";\n    return string.substring(start, end + 1);\n  }\n\n  public static void increaseCharCount(char c, Map<Character, Integer> charCounts) {\n    if (!charCounts.containsKey(c)) {\n      charCounts.put(c, 1);\n    } else {\n      charCounts.put(c, charCounts.get(c) + 1);\n    }\n  }\n\n  public static void decreaseCharCount(char c, Map<Character, Integer> charCounts) {\n    charCounts.put(c, charCounts.get(c) - 1);\n  }\n}\n"
      ]
    },
    "javascript": {
      "Language": "javascript",
      "StartingCode": "function smallestSubstringContaining(bigString, smallString) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.smallestSubstringContaining = smallestSubstringContaining;\n",
      "StartingTest": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const bigString = 'abcdef';\n  const smallString = 'fa';\n  const expected = 'abcdef';\n  chai.expect(program.smallestSubstringContaining(bigString, smallString)).to.deep.equal(expected);\n});\n\nit('Test Case #2', function () {\n  const bigString = 'abcdef';\n  const smallString = 'd';\n  const expected = 'd';\n  chai.expect(program.smallestSubstringContaining(bigString, smallString)).to.deep.equal(expected);\n});\n\nit('Test Case #3', function () {\n  const bigString = 'abcdefghijklmnopqrstuvwxyz';\n  const smallString = 'aajjttwwxxzz';\n  const expected = '';\n  chai.expect(program.smallestSubstringContaining(bigString, smallString)).to.deep.equal(expected);\n});\n\nit('Test Case #4', function () {\n  const bigString = 'abzacdwejxjftghiwjtklmnopqrstuvwxyz';\n  const smallString = 'aajjttwwxxzz';\n  const expected = 'abzacdwejxjftghiwjtklmnopqrstuvwxyz';\n  chai.expect(program.smallestSubstringContaining(bigString, smallString)).to.deep.equal(expected);\n});\n\nit('Test Case #5', function () {\n  const bigString = 'abzacdwejxjfxztghiwjtklmnopqrstuvwxyz';\n  const smallString = 'aajjttwwxxzz';\n  const expected = 'abzacdwejxjfxztghiwjt';\n  chai.expect(program.smallestSubstringContaining(bigString, smallString)).to.deep.equal(expected);\n});\n\nit('Test Case #6', function () {\n  const bigString = 'aaaa+a$+aaa++$+++++++aaa';\n  const smallString = 'a+$aaAaaaa$++';\n  const expected = '';\n  chai.expect(program.smallestSubstringContaining(bigString, smallString)).to.deep.equal(expected);\n});\n\nit('Test Case #7', function () {\n  const bigString = 'a$fuu+afff+affaffa+a$Affab+a+a+$a$';\n  const smallString = 'a+$aaAaaaa$++';\n  const expected = 'affa+a$Affab+a+a+$a';\n  chai.expect(program.smallestSubstringContaining(bigString, smallString)).to.deep.equal(expected);\n});\n\nit('Test Case #8', function () {\n  const bigString = 'a$fuu+afff+affaffa+a$Affab+a+a+$a$bccgtt+aaaacA+++aaa$';\n  const smallString = 'a+$aaAaaaa$++';\n  const expected = 'affa+a$Affab+a+a+$a';\n  chai.expect(program.smallestSubstringContaining(bigString, smallString)).to.deep.equal(expected);\n});\n\nit('Test Case #9', function () {\n  const bigString = '145624356128828193236336541277356789901';\n  const smallString = '123';\n  const expected = '1932';\n  chai.expect(program.smallestSubstringContaining(bigString, smallString)).to.deep.equal(expected);\n});\n\nit('Test Case #10', function () {\n  const bigString = '1456243561288281932363365412356789901!';\n  const smallString = '123!';\n  const expected = '2356789901!';\n  chai.expect(program.smallestSubstringContaining(bigString, smallString)).to.deep.equal(expected);\n});\n\nit('Test Case #11', function () {\n  const bigString = '14562435612!88281932363365$412356789901';\n  const smallString = '$123!';\n  const expected = '!88281932363365$';\n  chai.expect(program.smallestSubstringContaining(bigString, smallString)).to.deep.equal(expected);\n});\n\nit('Test Case #12', function () {\n  const bigString = '14562435612!88281932363365$412356789901';\n  const smallString = '#!123!';\n  const expected = '';\n  chai.expect(program.smallestSubstringContaining(bigString, smallString)).to.deep.equal(expected);\n});\n\nit('Test Case #13', function () {\n  const bigString = '14562435612!88281932363365$412356789901';\n  const smallString = '#!333333123!';\n  const expected = '';\n  chai.expect(program.smallestSubstringContaining(bigString, smallString)).to.deep.equal(expected);\n});\n\nit('Test Case #14', function () {\n  const bigString = '14562435612z!8828!193236!336!5$41!23!5!6789901#';\n  const smallString = '#!2z';\n  const expected = 'z!8828!193236!336!5$41!23!5!6789901#';\n  chai.expect(program.smallestSubstringContaining(bigString, smallString)).to.deep.equal(expected);\n});\n\nit('Test Case #15', function () {\n  const bigString = '14562435612z!8828!193236!336!5$41!23!5!6789901#z2!';\n  const smallString = '#!2z';\n  const expected = '#z2!';\n  chai.expect(program.smallestSubstringContaining(bigString, smallString)).to.deep.equal(expected);\n});\n\nit('Test Case #16', function () {\n  const bigString = 'abcd$ef$axb$c$';\n  const smallString = '$$abf';\n  const expected = 'f$axb$';\n  chai.expect(program.smallestSubstringContaining(bigString, smallString)).to.deep.equal(expected);\n});\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const bigString = 'abcd$ef$axb$c$';\n  const smallString = '$$abf';\n  const expected = 'f$axb$';\n  chai.expect(program.smallestSubstringContaining(bigString, smallString)).to.deep.equal(expected);\n});\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\n// O(b + s) time | O(b + s) space - where b is the length of the big\n// input string and s is the length of the small input string\nfunction smallestSubstringContaining(bigString, smallString) {\n  const targetCharCounts = getCharCounts(smallString);\n  const substringBounds = getSubstringBounds(bigString, targetCharCounts);\n  return getStringFromBounds(bigString, substringBounds);\n}\n\nfunction getCharCounts(string) {\n  const charCounts = {};\n  for (const char of string) {\n    increaseCharCount(char, charCounts);\n  }\n  return charCounts;\n}\n\nfunction getSubstringBounds(string, targetCharCounts) {\n  let substringBounds = [0, Infinity];\n  const substringCharCounts = {};\n  const numUniqueChars = Object.keys(targetCharCounts).length;\n  let numUniqueCharsDone = 0;\n  let leftIdx = 0;\n  let rightIdx = 0;\n  // Move the rightIdx to the right in the string until you've counted\n  // all of the target characters enough times.\n  while (rightIdx < string.length) {\n    const rightChar = string[rightIdx];\n    if (!(rightChar in targetCharCounts)) {\n      rightIdx++;\n      continue;\n    }\n    increaseCharCount(rightChar, substringCharCounts);\n    if (substringCharCounts[rightChar] === targetCharCounts[rightChar]) {\n      numUniqueCharsDone++;\n    }\n    // Move the leftIdx to the right in the string until you no longer\n    // have enough of the target characters in between the leftIdx and\n    // the rightIdx. Update the substringBounds accordingly.\n    while (numUniqueCharsDone === numUniqueChars && leftIdx <= rightIdx) {\n      substringBounds = getCloserBounds(leftIdx, rightIdx, substringBounds[0], substringBounds[1]);\n      const leftChar = string[leftIdx];\n      if (!(leftChar in targetCharCounts)) {\n        leftIdx++;\n        continue;\n      }\n      if (substringCharCounts[leftChar] === targetCharCounts[leftChar]) {\n        numUniqueCharsDone--;\n      }\n      decreaseCharCount(leftChar, substringCharCounts);\n      leftIdx++;\n    }\n    rightIdx++;\n  }\n  return substringBounds;\n}\n\nfunction getCloserBounds(idx1, idx2, idx3, idx4) {\n  return idx2 - idx1 < idx4 - idx3 ? [idx1, idx2] : [idx3, idx4];\n}\n\nfunction getStringFromBounds(string, bounds) {\n  const [start, end] = bounds;\n  if (end === Infinity) return '';\n  return string.slice(start, end + 1);\n}\n\nfunction increaseCharCount(char, charCounts) {\n  charCounts[char] = (charCounts[char] || 0) + 1;\n}\n\nfunction decreaseCharCount(char, charCounts) {\n  charCounts[char]--;\n}\n\nexports.smallestSubstringContaining = smallestSubstringContaining;\n"
      ]
    },
    "python": {
      "Language": "python",
      "StartingCode": "def smallestSubstringContaining(bigString, smallString):\n    # Write your code here.\n    pass\n",
      "StartingTest": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        bigString = \"abcdef\"\n        smallString = \"fa\"\n        expected = \"abcdef\"\n        self.assertEqual(program.smallestSubstringContaining(bigString, smallString), expected)\n\n    def test_case_2(self):\n        bigString = \"abcdef\"\n        smallString = \"d\"\n        expected = \"d\"\n        self.assertEqual(program.smallestSubstringContaining(bigString, smallString), expected)\n\n    def test_case_3(self):\n        bigString = \"abcdefghijklmnopqrstuvwxyz\"\n        smallString = \"aajjttwwxxzz\"\n        expected = \"\"\n        self.assertEqual(program.smallestSubstringContaining(bigString, smallString), expected)\n\n    def test_case_4(self):\n        bigString = \"abzacdwejxjftghiwjtklmnopqrstuvwxyz\"\n        smallString = \"aajjttwwxxzz\"\n        expected = \"abzacdwejxjftghiwjtklmnopqrstuvwxyz\"\n        self.assertEqual(program.smallestSubstringContaining(bigString, smallString), expected)\n\n    def test_case_5(self):\n        bigString = \"abzacdwejxjfxztghiwjtklmnopqrstuvwxyz\"\n        smallString = \"aajjttwwxxzz\"\n        expected = \"abzacdwejxjfxztghiwjt\"\n        self.assertEqual(program.smallestSubstringContaining(bigString, smallString), expected)\n\n    def test_case_6(self):\n        bigString = \"aaaa+a$+aaa++$+++++++aaa\"\n        smallString = \"a+$aaAaaaa$++\"\n        expected = \"\"\n        self.assertEqual(program.smallestSubstringContaining(bigString, smallString), expected)\n\n    def test_case_7(self):\n        bigString = \"a$fuu+afff+affaffa+a$Affab+a+a+$a$\"\n        smallString = \"a+$aaAaaaa$++\"\n        expected = \"affa+a$Affab+a+a+$a\"\n        self.assertEqual(program.smallestSubstringContaining(bigString, smallString), expected)\n\n    def test_case_8(self):\n        bigString = \"a$fuu+afff+affaffa+a$Affab+a+a+$a$bccgtt+aaaacA+++aaa$\"\n        smallString = \"a+$aaAaaaa$++\"\n        expected = \"affa+a$Affab+a+a+$a\"\n        self.assertEqual(program.smallestSubstringContaining(bigString, smallString), expected)\n\n    def test_case_9(self):\n        bigString = \"145624356128828193236336541277356789901\"\n        smallString = \"123\"\n        expected = \"1932\"\n        self.assertEqual(program.smallestSubstringContaining(bigString, smallString), expected)\n\n    def test_case_10(self):\n        bigString = \"1456243561288281932363365412356789901!\"\n        smallString = \"123!\"\n        expected = \"2356789901!\"\n        self.assertEqual(program.smallestSubstringContaining(bigString, smallString), expected)\n\n    def test_case_11(self):\n        bigString = \"14562435612!88281932363365$412356789901\"\n        smallString = \"$123!\"\n        expected = \"!88281932363365$\"\n        self.assertEqual(program.smallestSubstringContaining(bigString, smallString), expected)\n\n    def test_case_12(self):\n        bigString = \"14562435612!88281932363365$412356789901\"\n        smallString = \"#!123!\"\n        expected = \"\"\n        self.assertEqual(program.smallestSubstringContaining(bigString, smallString), expected)\n\n    def test_case_13(self):\n        bigString = \"14562435612!88281932363365$412356789901\"\n        smallString = \"#!333333123!\"\n        expected = \"\"\n        self.assertEqual(program.smallestSubstringContaining(bigString, smallString), expected)\n\n    def test_case_14(self):\n        bigString = \"14562435612z!8828!193236!336!5$41!23!5!6789901#\"\n        smallString = \"#!2z\"\n        expected = \"z!8828!193236!336!5$41!23!5!6789901#\"\n        self.assertEqual(program.smallestSubstringContaining(bigString, smallString), expected)\n\n    def test_case_15(self):\n        bigString = \"14562435612z!8828!193236!336!5$41!23!5!6789901#z2!\"\n        smallString = \"#!2z\"\n        expected = \"#z2!\"\n        self.assertEqual(program.smallestSubstringContaining(bigString, smallString), expected)\n\n    def test_case_16(self):\n        bigString = \"abcd$ef$axb$c$\"\n        smallString = \"$$abf\"\n        expected = \"f$axb$\"\n        self.assertEqual(program.smallestSubstringContaining(bigString, smallString), expected)\n",
      "SandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        bigString = \"abcd$ef$axb$c$\"\n        smallString = \"$$abf\"\n        expected = \"f$axb$\"\n        self.assertEqual(program.smallestSubstringContaining(bigString, smallString), expected)\n",
      "Solutions": [
        "# Copyright © 2020 Code Complete. All rights reserved.\n\n# O(b + s) time | O(b + s) space - where b is the length of the big\n# input string and s is the length of the small input string\ndef smallestSubstringContaining(bigString, smallString):\n    targetCharCounts = getCharCounts(smallString)\n    substringBounds = getSubstringBounds(bigString, targetCharCounts)\n    return getStringFromBounds(bigString, substringBounds)\n\n\ndef getCharCounts(string):\n    charCounts = {}\n    for char in string:\n        increaseCharCount(char, charCounts)\n    return charCounts\n\n\ndef getSubstringBounds(string, targetCharCounts):\n    substringBounds = [0, float(\"inf\")]\n    substringCharCounts = {}\n    numUniqueChars = len(targetCharCounts.keys())\n    numUniqueCharsDone = 0\n    leftIdx = 0\n    rightIdx = 0\n    # Move the rightIdx to the right in the string until you've counted\n    # all of the target characters enough times.\n    while rightIdx < len(string):\n        rightChar = string[rightIdx]\n        if rightChar not in targetCharCounts:\n            rightIdx += 1\n            continue\n        increaseCharCount(rightChar, substringCharCounts)\n        if substringCharCounts[rightChar] == targetCharCounts[rightChar]:\n            numUniqueCharsDone += 1\n        # Move the leftIdx to the right in the string until you no longer\n        # have enough of the target characters in between the leftIdx and\n        # the rightIdx. Update the substringBounds accordingly.\n        while numUniqueCharsDone == numUniqueChars and leftIdx <= rightIdx:\n            substringBounds = getCloserBounds(leftIdx, rightIdx, substringBounds[0], substringBounds[1])\n            leftChar = string[leftIdx]\n            if leftChar not in targetCharCounts:\n                leftIdx += 1\n                continue\n            if substringCharCounts[leftChar] == targetCharCounts[leftChar]:\n                numUniqueCharsDone -= 1\n            decreaseCharCount(leftChar, substringCharCounts)\n            leftIdx += 1\n        rightIdx += 1\n    return substringBounds\n\n\ndef getCloserBounds(idx1, idx2, idx3, idx4):\n    return [idx1, idx2] if idx2 - idx1 < idx4 - idx3 else [idx3, idx4]\n\n\ndef getStringFromBounds(string, bounds):\n    start, end = bounds\n    if end == float(\"inf\"):\n        return \"\"\n    return string[start : end + 1]\n\n\ndef increaseCharCount(char, charCounts):\n    if char not in charCounts:\n        charCounts[char] = 0\n    charCounts[char] += 1\n\n\ndef decreaseCharCount(char, charCounts):\n    charCounts[char] -= 1\n"
      ]
    },
    "swift": {
      "Language": "swift",
      "StartingCode": "class Program {\n  func smallestSubstringContaining(_ bigString: String, _ smallString: String) -> String {\n    // Write your code here.\n    return \"\"\n  }\n}\n",
      "StartingTest": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let bigString = \"abcdef\"\n      let smallString = \"fa\"\n      let expected = \"abcdef\"\n      let output = program.smallestSubstringContaining(bigString, smallString)\n      try assertEqual(output, expected)\n    }\n\n    runTest(\"Test Case 2\") { () throws -> Void in\n      let bigString = \"abcdef\"\n      let smallString = \"d\"\n      let expected = \"d\"\n      let output = program.smallestSubstringContaining(bigString, smallString)\n      try assertEqual(output, expected)\n    }\n\n    runTest(\"Test Case 3\") { () throws -> Void in\n      let bigString = \"abcdefghijklmnopqrstuvwxyz\"\n      let smallString = \"aajjttwwxxzz\"\n      let expected = \"\"\n      let output = program.smallestSubstringContaining(bigString, smallString)\n      try assertEqual(output, expected)\n    }\n\n    runTest(\"Test Case 4\") { () throws -> Void in\n      let bigString = \"abzacdwejxjftghiwjtklmnopqrstuvwxyz\"\n      let smallString = \"aajjttwwxxzz\"\n      let expected = \"abzacdwejxjftghiwjtklmnopqrstuvwxyz\"\n      let output = program.smallestSubstringContaining(bigString, smallString)\n      try assertEqual(output, expected)\n    }\n\n    runTest(\"Test Case 5\") { () throws -> Void in\n      let bigString = \"abzacdwejxjfxztghiwjtklmnopqrstuvwxyz\"\n      let smallString = \"aajjttwwxxzz\"\n      let expected = \"abzacdwejxjfxztghiwjt\"\n      let output = program.smallestSubstringContaining(bigString, smallString)\n      try assertEqual(output, expected)\n    }\n\n    runTest(\"Test Case 6\") { () throws -> Void in\n      let bigString = \"aaaa+a$+aaa++$+++++++aaa\"\n      let smallString = \"a+$aaAaaaa$++\"\n      let expected = \"\"\n      let output = program.smallestSubstringContaining(bigString, smallString)\n      try assertEqual(output, expected)\n    }\n\n    runTest(\"Test Case 7\") { () throws -> Void in\n      let bigString = \"a$fuu+afff+affaffa+a$Affab+a+a+$a$\"\n      let smallString = \"a+$aaAaaaa$++\"\n      let expected = \"affa+a$Affab+a+a+$a\"\n      let output = program.smallestSubstringContaining(bigString, smallString)\n      try assertEqual(output, expected)\n    }\n\n    runTest(\"Test Case 8\") { () throws -> Void in\n      let bigString = \"a$fuu+afff+affaffa+a$Affab+a+a+$a$bccgtt+aaaacA+++aaa$\"\n      let smallString = \"a+$aaAaaaa$++\"\n      let expected = \"affa+a$Affab+a+a+$a\"\n      let output = program.smallestSubstringContaining(bigString, smallString)\n      try assertEqual(output, expected)\n    }\n\n    runTest(\"Test Case 9\") { () throws -> Void in\n      let bigString = \"145624356128828193236336541277356789901\"\n      let smallString = \"123\"\n      let expected = \"1932\"\n      let output = program.smallestSubstringContaining(bigString, smallString)\n      try assertEqual(output, expected)\n    }\n\n    runTest(\"Test Case 10\") { () throws -> Void in\n      let bigString = \"1456243561288281932363365412356789901!\"\n      let smallString = \"123!\"\n      let expected = \"2356789901!\"\n      let output = program.smallestSubstringContaining(bigString, smallString)\n      try assertEqual(output, expected)\n    }\n\n    runTest(\"Test Case 11\") { () throws -> Void in\n      let bigString = \"14562435612!88281932363365$412356789901\"\n      let smallString = \"$123!\"\n      let expected = \"!88281932363365$\"\n      let output = program.smallestSubstringContaining(bigString, smallString)\n      try assertEqual(output, expected)\n    }\n\n    runTest(\"Test Case 12\") { () throws -> Void in\n      let bigString = \"14562435612!88281932363365$412356789901\"\n      let smallString = \"#!123!\"\n      let expected = \"\"\n      let output = program.smallestSubstringContaining(bigString, smallString)\n      try assertEqual(output, expected)\n    }\n\n    runTest(\"Test Case 13\") { () throws -> Void in\n      let bigString = \"14562435612!88281932363365$412356789901\"\n      let smallString = \"#!333333123!\"\n      let expected = \"\"\n      let output = program.smallestSubstringContaining(bigString, smallString)\n      try assertEqual(output, expected)\n    }\n\n    runTest(\"Test Case 14\") { () throws -> Void in\n      let bigString = \"14562435612z!8828!193236!336!5$41!23!5!6789901#\"\n      let smallString = \"#!2z\"\n      let expected = \"z!8828!193236!336!5$41!23!5!6789901#\"\n      let output = program.smallestSubstringContaining(bigString, smallString)\n      try assertEqual(output, expected)\n    }\n\n    runTest(\"Test Case 15\") { () throws -> Void in\n      let bigString = \"14562435612z!8828!193236!336!5$41!23!5!6789901#z2!\"\n      let smallString = \"#!2z\"\n      let expected = \"#z2!\"\n      let output = program.smallestSubstringContaining(bigString, smallString)\n      try assertEqual(output, expected)\n    }\n\n    runTest(\"Test Case 16\") { () throws -> Void in\n      let bigString = \"abcd$ef$axb$c$\"\n      let smallString = \"$$abf\"\n      let expected = \"f$axb$\"\n      let output = program.smallestSubstringContaining(bigString, smallString)\n      try assertEqual(output, expected)\n    }\n  }\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let bigString = \"abcd$ef$axb$c$\"\n      let smallString = \"$$abf\"\n      let expected = \"f$axb$\"\n      let output = program.smallestSubstringContaining(bigString, smallString)\n      try assertEqual(output, expected)\n    }\n  }\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nclass Program {\n  // O(b + s) time | O(b + s) space - where b is the length of the big\n  // input string and s is the length of the small input string\n  func smallestSubstringContaining(_ bigString: String, _ smallString: String) -> String {\n    let targetCharCounts = getCharCounts(smallString)\n    let substringBounds = getSubstringBounds(bigString, targetCharCounts)\n    return getStringFromBounds(bigString, substringBounds)\n  }\n\n  func getCharCounts(_ str: String) -> [Character: Int] {\n    var charCounts = [Character: Int]()\n    for char in str {\n      changeCharCount(char, &charCounts, 1)\n    }\n    return charCounts\n  }\n\n  func changeCharCount(_ char: Character, _ charCounts: inout [Character: Int], _ change: Int) {\n    if let count = charCounts[char] {\n      charCounts.updateValue(count + change, forKey: char)\n      return\n    }\n    charCounts[char] = change\n  }\n\n  func getSubstringBounds(_ str: String, _ targetCharCounts: [Character: Int]) -> [Int] {\n    var substringBounds = [0, Int.max]\n    var substringCharCounts = [Character: Int]()\n    var numUniqueChars = targetCharCounts.count\n    var numUniqueCharsDone = 0\n    var leftIdx = 0\n    var rightIdx = 0\n\n    // Move the rightIdx to the right in the string until you've counted\n    // all of the target characters enough times.\n    while rightIdx < str.length {\n      let rightStringIndex = str.index(str.startIndex, offsetBy: rightIdx)\n\n      let rightChar = str[rightStringIndex]\n      if targetCharCounts[rightChar] == nil {\n        rightIdx += 1\n        continue\n      }\n      changeCharCount(rightChar, &substringCharCounts, 1)\n      if substringCharCounts[rightChar] == targetCharCounts[rightChar] {\n        numUniqueCharsDone += 1\n      }\n\n      // Move the leftIdx to the right in the string until you no longer\n      // have enough of the target characters in between the leftIdx and\n      // the rightIdx. Update the substringBounds accordingly.\n      while numUniqueCharsDone == numUniqueChars, leftIdx <= rightIdx {\n        let leftStringIndex = str.index(str.startIndex, offsetBy: leftIdx)\n        substringBounds = getCloserBounds(leftIdx, rightIdx,\n                                          substringBounds[0], substringBounds[1])\n        let leftChar = str[leftStringIndex]\n        if substringCharCounts[leftChar] == nil {\n          leftIdx += 1\n          continue\n        }\n        if substringCharCounts[leftChar] == targetCharCounts[leftChar] {\n          numUniqueCharsDone -= 1\n        }\n        changeCharCount(leftChar, &substringCharCounts, -1)\n        leftIdx += 1\n      }\n      rightIdx += 1\n    }\n\n    return substringBounds\n  }\n\n  func getCloserBounds(_ idx1: Int, _ idx2: Int, _ idx3: Int, _ idx4: Int) -> [Int] {\n    if idx2 - idx1 < idx4 - idx3 {\n      return [idx1, idx2]\n    }\n    return [idx3, idx4]\n  }\n\n  func getStringFromBounds(_ str: String, _ bounds: [Int]) -> String {\n    let start = bounds[0]\n    let end = bounds[1]\n    if end == Int.max {\n      return \"\"\n    }\n\n    let startIdx = str.index(str.startIndex, offsetBy: start)\n    let endIdx = str.index(str.startIndex, offsetBy: end + 1)\n    let newStr = str[startIdx ..< endIdx]\n    return String(newStr)\n  }\n}\n"
      ]
    },
    "typescript": {
      "Language": "typescript",
      "StartingCode": "export function smallestSubstringContaining(bigString: string, smallString: string) {\n  // Write your code here.\n  return '';\n}\n",
      "StartingTest": "",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const bigString = 'abcd$ef$axb$c$';\n  const smallString = '$$abf';\n  const expected = 'f$axb$';\n  chai.expect(program.smallestSubstringContaining(bigString, smallString)).to.deep.equal(expected);\n});\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\ninterface CharCounts {\n  [key: string]: number;\n}\n\ntype Bounds = [number, number];\n\n// O(b + s) time | O(b + s) space - where b is the length of the big\n// input string and s is the length of the small input string\nexport function smallestSubstringContaining(bigString: string, smallString: string) {\n  const targetCharCounts = getCharCounts(smallString);\n  const substringBounds = getSubstringBounds(bigString, targetCharCounts);\n  return getStringFromBounds(bigString, substringBounds);\n}\n\nfunction getCharCounts(string: string) {\n  const charCounts: CharCounts = {};\n  for (const char of string) {\n    increaseCharCount(char, charCounts);\n  }\n  return charCounts;\n}\n\nfunction getSubstringBounds(string: string, targetCharCounts: CharCounts) {\n  let substringBounds: Bounds = [0, Infinity];\n  const substringCharCounts: CharCounts = {};\n  const numUniqueChars = Object.keys(targetCharCounts).length;\n  let numUniqueCharsDone = 0;\n  let leftIdx = 0;\n  let rightIdx = 0;\n  // Move the rightIdx to the right in the string until you've counted\n  // all of the target characters enough times.\n  while (rightIdx < string.length) {\n    const rightChar = string[rightIdx];\n    if (!(rightChar in targetCharCounts)) {\n      rightIdx++;\n      continue;\n    }\n    increaseCharCount(rightChar, substringCharCounts);\n    if (substringCharCounts[rightChar] === targetCharCounts[rightChar]) {\n      numUniqueCharsDone++;\n    }\n    // Move the leftIdx to the right in the string until you no longer\n    // have enough of the target characters in between the leftIdx and\n    // the rightIdx. Update the substringBounds accordingly.\n    while (numUniqueCharsDone === numUniqueChars && leftIdx <= rightIdx) {\n      substringBounds = getCloserBounds(leftIdx, rightIdx, substringBounds[0], substringBounds[1]);\n      const leftChar = string[leftIdx];\n      if (!(leftChar in targetCharCounts)) {\n        leftIdx++;\n        continue;\n      }\n      if (substringCharCounts[leftChar] === targetCharCounts[leftChar]) {\n        numUniqueCharsDone--;\n      }\n      decreaseCharCount(leftChar, substringCharCounts);\n      leftIdx++;\n    }\n    rightIdx++;\n  }\n  return substringBounds;\n}\n\nfunction getCloserBounds(idx1: number, idx2: number, idx3: number, idx4: number): Bounds {\n  return idx2 - idx1 < idx4 - idx3 ? [idx1, idx2] : [idx3, idx4];\n}\n\nfunction getStringFromBounds(string: string, bounds: Bounds) {\n  const [start, end] = bounds;\n  if (end === Infinity) return '';\n  return string.slice(start, end + 1);\n}\n\nfunction increaseCharCount(char: string, charCounts: CharCounts) {\n  charCounts[char] = (charCounts[char] || 0) + 1;\n}\n\nfunction decreaseCharCount(char: string, charCounts: CharCounts) {\n  charCounts[char]--;\n}\n"
      ]
    }
  },
  "JSONTestLanguages": [
    "javascript",
    "cpp",
    "python",
    "java",
    "csharp",
    "go",
    "swift",
    "typescript"
  ],
  "JSONTests": [
    {
      "bigString": "abcd$ef$axb$c$",
      "smallString": "$$abf"
    },
    {
      "bigString": "abcdef",
      "smallString": "fa"
    },
    {
      "bigString": "abcdef",
      "smallString": "d"
    },
    {
      "bigString": "abcdefghijklmnopqrstuvwxyz",
      "smallString": "aajjttwwxxzz"
    },
    {
      "bigString": "abzacdwejxjftghiwjtklmnopqrstuvwxyz",
      "smallString": "aajjttwwxxzz"
    },
    {
      "bigString": "abzacdwejxjfxztghiwjtklmnopqrstuvwxyz",
      "smallString": "aajjttwwxxzz"
    },
    {
      "bigString": "aaaa+a$+aaa++$+++++++aaa",
      "smallString": "a+$aaAaaaa$++"
    },
    {
      "bigString": "a$fuu+afff+affaffa+a$Affab+a+a+$a$",
      "smallString": "a+$aaAaaaa$++"
    },
    {
      "bigString": "a$fuu+afff+affaffa+a$Affab+a+a+$a$bccgtt+aaaacA+++aaa$",
      "smallString": "a+$aaAaaaa$++"
    },
    {
      "bigString": "145624356128828193236336541277356789901",
      "smallString": "123"
    },
    {
      "bigString": "1456243561288281932363365412356789901!",
      "smallString": "123!"
    },
    {
      "bigString": "14562435612!88281932363365$412356789901",
      "smallString": "$123!"
    },
    {
      "bigString": "14562435612!88281932363365$412356789901",
      "smallString": "#!123!"
    },
    {
      "bigString": "14562435612!88281932363365$412356789901",
      "smallString": "#!333333123!"
    },
    {
      "bigString": "14562435612z!8828!193236!336!5$41!23!5!6789901#",
      "smallString": "#!2z"
    },
    {
      "bigString": "14562435612z!8828!193236!336!5$41!23!5!6789901#z2!",
      "smallString": "#!2z"
    }
  ],
  "JSONAnswers": [
    [
      "f$axb$",
      "abcdef",
      "d",
      "",
      "abzacdwejxjftghiwjtklmnopqrstuvwxyz",
      "abzacdwejxjfxztghiwjt",
      "",
      "affa+a$Affab+a+a+$a",
      "affa+a$Affab+a+a+$a",
      "1932",
      "2356789901!",
      "!88281932363365$",
      "",
      "",
      "z!8828!193236!336!5$41!23!5!6789901#",
      "#z2!"
    ]
  ]
}